\documentclass{article}
% \documentclass[review]{elsarticle}
\usepackage{epsfig}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage[algo2e,noend]{algorithm2e}
\usepackage[compatible,noend]{algpseudocode}
\usepackage{enumitem}
\usepackage{xspace}
\usepackage[table,xcdraw]{xcolor}
\usepackage{amsfonts}
\usepackage{pifont}
\usepackage{bbding}
\usepackage[english]{babel}
\usepackage{adjustbox}
\usepackage{tikz}
\usepackage{subcaption}
\usetikzlibrary{automata, topaths, calc, positioning, shapes, backgrounds, fit, matrix}
\usepackage{caption}
\usepackage{tabularx}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{datatool}
\usepackage{array}
\usepackage{pgfplotstable}
\pgfplotsset{width=7cm,compat=newest}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{pdflscape}
\usepackage{afterpage}
\usepackage{capt-of}
\usepackage{multirow}
\usepackage{float}
\usepackage[text={15cm,21cm},centering]{geometry}
\usepackage{setspace}
\usepackage{array}
\allowdisplaybreaks
\usepackage{lineno}
\usepackage{breqn}
\usepackage{tkz-graph}

\newcolumntype{H}{>{\setbox0=\hbox\bgroup}c<{\egroup}@{}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newcommand{\pcmaxc}{P$|\mbox{\em cont}|$C$_{\max}$\xspace}

\newcommand{\GRASP}{Greedy randomized adaptive search procedure\xspace}
\newcommand{\F}{$\mathcal{F}$\xspace}
\newcommand{\B}{$\mathcal{B}$\xspace}
\newcommand{\C}{$\mathcal{C}$\xspace}
\newcommand{\LB}{$\mathcal{L}$\xspace}
\newcommand{\Lb}{$\mathcal{L}_b$\xspace}
\newcommand{\D}{$\mathcal{D}$\xspace}
 \newcommand*{\red}{\textcolor{red}}

\renewcommand{\algorithmicforall}{\textbf{for each}}
\SetKwFor{ForEach}{for each}{}{}%
\renewcommand{\algorithmiccomment}[2][1\linewidth]{%
\leavevmode\hfill\makebox[#1][l]{/* \textbf{~#2} */}}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}

\renewcommand{\tabcolsep}{4pt}

\modulolinenumbers[1]
% \linenumbers

\oddsidemargin=0.5in
\topmargin=-0.25in
\textwidth=5.5in
\textheight=8.25in

%\journal{European Journal of Operational Research}

%\begin{frontmatter}

		
\title{A GRASP algorithm for the concrete delivery problem. }
\author{Ousmane Ali$^{(1)}$, Jean-Fran\c cois C\^ot\'e$^{(2)}$, Leandro C.~Coelho$^{(3)}$\\
 $(1)$ {\tt nassoma-wattara-ousmane.ali.1@ulaval.ca}\\
 $(2)$ {\tt Jean-Francois.Cote@fsa.ulaval.ca}\\
 $(3)$ {\tt Leandro.Coelho@fsa.ulaval.ca}\\
}

% \date{\today}

\begin{document}
\maketitle
\begin{abstract}
  This paper addresses a novel variant of the Concrete Delivery Problem (CDP), which involves the efficient scheduling of ready-mixed concrete deliveries to construction sites while balancing the conflicting goals of minimizing transportation costs and maximizing customer satisfaction. In this study, we propose an exact formulation and a heuristic approach based on the Greedy Randomized Adaptive Search Procedure (GRASP), to tackle this challenging CDP variant. This variant introduces realistic side constraints, including driver working shifts, a minimum driver working time, and overtime penalties. Additionally, it considers the case where customers may request multiple types of concrete delivered within the same time window. We assess the performance of our heuristic using new instances generated for this problem and provide a comparative analysis with another CDP variant to demonstrate its effectiveness.
\end{abstract}


% \begin{keywords}
\noindent{\textbf{Keywords:} Vehicle scheduling;  concrete delivery; GRASP; ready-mixed concrete}
% \end{keywords}


\section{Introduction}
\label{sec:cdp_intro}
Concrete is a widely used building material in construction projects. Its perishable nature is affected by many factors that impact its quality \citep{sinha_quality_2021}, which is crucial for the durability and strength of the final construction. Concrete comes in two types: ready-mixed concrete (RMC) and site-mixed concrete (SMC). RMC is manufactured in a batch plant and delivered to the construction site, while SMC is produced on-site using raw materials stored on the construction site. Using SMC can avoid delays caused by road traffic, but it has a slower and more difficult production process, requires storage for mixing materials and equipment, and is suitable for low amounts of concrete. On the other hand, RMC has better quality and benefits from lower production costs \citep{muresan_comparing}. However, to take advantage of these benefits, the batch plant manager must ensure efficient and prompt delivery on the construction site, which may require a fleet of high-cost revolving drum trucks (concrete mixers) to dispatch the RMC.

Concrete delivery under the form of RMC is subject to many operational constraints that make the Concrete Delivery Problem (CDP) very challenging. In this paper, we study a variant of the CDP to schedule the daily production and dispatching of RMC for a company located in the province of Quebec, Canada. This company operates multiple batch plants with varying production rates, using a fleet of concrete mixers of different capacities. Each plant has its own fleet of trucks; however, under certain conditions, the trucks can move between plants if necessary. The trucks must return to their home plant at the end of the day. The company owns two types of trucks with different capacities and can call on an external fleet when needed. They serve construction sites from any of their plants, with the first delivery starting at the time specified by the customer. The loading and unloading of a concrete mixer depend on the truck capacity, the loading rate at the plant, and the unloading rate at the construction site. Drivers are allocated based on their daily work schedules. A customer may request several types of concrete to be delivered within the same time window, with no required sequence for the orders, but an order can only start after the completion of the previous order. This constraint generalizes the linked order constraints of \cite{durbin2008or} where some customers place two orders for the same day and request that they are linked (the second order begins only after the first order is completed). The setting of our study is similar to a variant of the CDP previously studied in \cite{schmid2009hybrid, schmid2010hybridization}. However, we include the plant's production rate and driver shift schedule. The company uses a centralized dispatcher system to schedule all daily orders, but this system has issues satisfying all daily demands without using an external fleet or using different plants to serve the same order.

According to \cite{blazewicz2019handbook}, the CDP combines vehicle routing with scheduling issues to plan routes to deliver concrete from batch plants (depots) to customers' construction sites. RMC is an on-demand product with a short life cycle from production through end use. It cannot be stored and cannot stay too long on a truck, or it will harden. Hence, concrete mixers must deliver RMC at the planned construction site shortly after its production. A customer quantity requirement is often greater than the truck size and must be fulfilled by multiple deliveries. In that sense, CDP is similar to the vehicle routing problem with split delivery \citep{archetti2008split}, except that the same truck may visit a customer more than once. Concrete hardens quickly, so multiple deliveries must be done back-to-back or at least close in time to avoid the problem of cold joint, which can reduce the strength and durability of the concrete. Customers request to be served within a specific time window, which can complicate truck-loading schedules when a plant can only load one truck at a time. Similarly, only one truck can unload at a time at a customer location, sometimes leading to concrete mixers queuing and waiting their turn to deliver. Furthermore, with trucks of varied sizes, loading, travel, and unloading times that may be uncertain, the CDP is a complex and challenging problem.

In this paper, we propose a mathematical model and a Greedy Randomized Search Procedure (GRASP) heuristic to solve a new variant of the CDP. Our model takes into consideration the working shifts of the drivers and the scheduling of multiple orders within the same time window at a construction site. To the best of our knowledge, this paper is the first that deals with these specific constraints in the context of the CDP.

The rest of the paper is organized as follows: Section \ref{sec:cdp_lit_review} provides a literature review of previous works related to the CDP. Section~\ref{sec:cdp_desc_form} provides a formal description and mathematical model of the problem. Section~\ref{sec:cdp_grasp_method} describes the GRASP algorithm and the constructive heuristics developed to solve this variant of the CDP. Section~\ref{sec:cdp_comp_exp} presents computational experiments and sensitivity analyses to evaluate the proposed approach, and finally, we conclude in  Section~\ref{sec:cdp_concl}.

\section{Literature review}
\label{sec:cdp_lit_review}

Academic Research on concrete batch and delivery began in the late 1990s. \cite{tommelein1999just} described RMC as a prototypical example of a JIT production system in construction and identified two practices for delivering it. One approach is for the customer to haul the product from the batch plant with their concrete mixer, while the other is for the batch plant to deliver the concrete directly to the customer's location. This latter approach is the one that has been studied in all related papers found in the literature. Several works to schedule and dispatch concrete production and delivery have mainly focused on simulation-related methods. These methods can be standalone, such as those used by \cite{zayed2001simulation, wang2001scheduling} and  \cite{panas_simulation_based_2013}, among others. Alternatively, these methods can be hybridized with optimization techniques, such as those used by \cite{feng2004optimizing} and \cite{lu2005optimized}. \cite{wang2001scheduling} developed a simulation model to reveal the effect and value of the concrete mixers' inter-arrival time on the productivity of hired unloading equipment on site. \cite{feng2004optimizing} used a combination of genetic algorithm (GA) and simulation process to minimize the total waiting time for trucks at a customer site. The study focused on loading trucks with identical capacities at the same batch plant, with fixed loading and unloading durations. The GA was used to find the best loading sequence of RMC trucks to be assigned to different construction sites. The simulation process determined the loading, arrival, departure, and waiting time of trucks and thus evaluated the cost of each dispatching sequence. They evaluated their method using data from a batch plant in Taiwan with up to nine customers served. \cite{lu2005optimized} used the same combination of GA and simulation to determine the optimal number of concrete mixers to be deployed and an optimal schedule for batching and delivering concrete. Their objective was to minimize the idle time of the site crew due to late concrete deliveries and truck queuing time. In this setting, it was also necessary to deliver a batch of mortar on-site to lubricate the unloading pump before the concrete delivery. As such, the simulation model also included the batch and delivery of mortar. Finding the best RMC fleet size was also the purpose of the discrete-event simulation model proposed by \cite{panas_simulation_based_2013}.

In addition to simulation-based methods, several other approaches have been used in the literature to solve the CDP. These include metaheuristics \citep{misir2011selection, maghrebi2016sequential, yang2022concrete}, exact methods \citep{asbach2009analysis, kinable2014concrete}, matheuristics \citep{schmid2009hybrid, schmid2010hybridization}, Benders Decomposition \citep{maghrebi2014benders}, column generation (CG) \citep{maghrebi2014solving, maghrebi2016column}, Lagrangian relaxation \citep{narayanan2015using}, and machine learning approaches \citep{graham2006modeling, maghrebi2016matching}. \cite{matsatsinis2004towards} designed a decision support system (DSS) for the dynamic routing of both concrete and pumps that may be necessary for some construction sites to aid in the unloading of concrete. The DSS considered the availability of three plants but stipulated that vehicles fulfilling the same order must all load at the same plant. Orders that could not be executed immediately could be postponed for the next day. The routing of the pumps was modeled as a multi-depot vehicle routing problem with time windows. \cite{naso2007genetic} proposed a sequential GA method combined with constructive heuristics to solve another variant of the CDP. In this problem, the plant's production schedule must consider orders that must be delivered to a customer's site as well as orders that must be picked up by the customer. The algorithm schedules the plant loading operations first before scheduling the truck deliveries. The authors also developed a non-linear model that minimizes transportation costs, waiting times, outsourced costs, and overtime work. They ran experiments using real-world instances of a concrete supply chain in the Netherlands and found a reduction in the number of outsourced requests. \cite{yan2007optimal} also considered overtime considerations in their paper, which focused on scheduling RMC for one batch plant with two loading docks. The study took into account that overtime wages are paid for factory and construction site operations after 4 PM. They developed a mixed-integer programming (MIP) model on a time-space network to minimize travel times and operating costs at both normal and overtime working hours at the plant and the construction sites. They tested the model using real data consisting of three days of operation using a two-stage algorithm. First, they solved the MIP relaxation with CPLEX. Then, they simplified the original model by fixing some decision variables before solving it. The algorithm was found to improve the actual plant operation by 10\%. A time-space network is the key component of the real-time DSS developed by \cite{durbin2008or} to solve a dynamic CDP every five minutes. The DSS can receive new orders, schedule them on the fly, and handle unexpected events such as plant closures, truck breakdowns, and delays in transportation times. The authors combined the DSS with a tabu search (TS) heuristic to warm start CPLEX, which made the model performant enough to solve instances with up to 1,500 loads per day with up to 250 trucks. The DSS also considers the case of a customer who places two orders, with the first being completed before the second starts. Further insights on the real-time planning and monitoring of CDP are available in \cite{garza2021dynamic}. Another variant of the CDP is modeled by \cite{schmid2009hybrid} as an integer multicommodity network flow (MCNF) problem on a time-space network. In this paper, concrete is delivered using a heterogeneous fleet of vehicles, and each plant can load an unlimited number of trucks simultaneously. Some of the trucks have specialized equipment and must arrive first at certain construction sites to assist in unloading the concrete. The objective is to fulfill all orders, minimize the travel cost, and avoid delays between two consecutive unloading operations for an order. The model is typically solved using a matheuristic algorithm that combines the MCNF with a variable neighborhood search (VNS) heuristic. The method can quickly solve large problem instances with more than 60 orders per day. The same problem is addressed by \cite{schmid2010hybridization}, who proposed a MIP model combined with a VNS and a very large neighborhood search (VLNS) to develop two matheuristics approaches. Comparisons between both matheuristics and a standalone VNS show that the former methods are much better and suitable for solving larger problem instances. These methods also provide better solutions for small to medium instances than the matheuristic used in \cite{schmid2009hybrid}. A pure VNS approach with the same problem but without the use of instrumentation has been applied by \cite{payr2009optimizing}.

Regarding objectives, most authors have focused on minimizing travel time and delays between consecutive deliveries. However, some authors have been more interested in maximizing customer satisfaction alone. We find these situations in the works of \cite{durbin2008or} and \cite{kinable2014concrete}. \cite{kinable2014concrete} introduce a general MIP and constraint programming (CP) models of the CDP reflecting the main constraints commonly found in all CDP works: time lag and no overlapping between consecutive deliveries, covering of all customers' demands, delivery time window, and heterogeneous fleet. However, the model did not include constraints limiting the time that concrete may reside in a truck. The authors propose a constructive heuristic that schedules the visits to the customers one by one according to the start time of the visit and the truck capacity. The procedure is invoked multiple times for different permutations of the customer's order which is determined using the steepest descent local search procedure. One of the paper's main contributions is the creation of the first public test instances for the CDP with up to 50 customers, four batch plants, and 20 concrete mixers. They found the CP model to be highly effective in finding high-quality solutions in a relatively short time or improving existing schedules, while the MIP model can be used to compute bounds, as it seems ineffective in solving large problem instances. Finally, the heuristic often yields good solutions in less than a second. A generalization of the MIP model of \cite{kinable2014concrete} is addressed in \cite{asbach2009analysis}. This model simultaneously minimizes the total sum of travel costs and the penalty costs for customers with unfulfilled demand. A customer can request that all concrete deliveries come from the same plant or a subset of plants and that a delivery truck belongs to a subset of the vehicle fleet. The MIP model is used in a local search scheme as a black-box solver to reoptimize an incumbent solution in which a neighborhood operator has unfixed some variables. \cite{tzanetos2023systematic} provide an overview of the various methods used in the literature to address the CDP and categorizes the problem formulations based on the different concepts used in the literature. They also discussed the consistency between industry needs and existing constraints and provided insights into the datasets corresponding to real-world cases, identifying the necessary data for practitioners.

\section{Problem description}
\label{sec:cdp_desc_form}
The focus of this paper is on the distribution of RMC from a Canadian company that operates in the greater Montreal area. When a customer places an order, it is received at a control center and immediately assigned to one of the company's batch plants. These plants produce the concrete and then deliver it to the customer. The problem involves a set of batch plants, a set of concrete-mixer drivers, and a set of customer orders.

Each of the company's plants has a single loading dock that can accommodate only one truck at a time. As a result, trucks often form a queue while waiting for their turn at the loading dock. Let $B$ be the set of batch plants. The plants are heterogeneous, as each plant $b$ has its hourly loading rate, represented by $\tau^l_b$, which affects the duration of the loading process. After loading the concrete, the driver spends $\alpha_b$ minutes adjusting the concrete in the truck before heading to the customer site. Each plant has its own assigned fleet of trucks, but it can borrow trucks from other plants. Let $l_{j}$ be the loading dock node associated with delivery node $j$. After loading RMC at $l_j$, it must be fully delivered to $j$ at most before $\Delta$ time, which is the concrete lifetime. We denote $L_b$ as the set of loading dock nodes of plant $b$ and $L$ as the set of all loading docks.

The company has two types of concrete mixer trucks with 8 and 12 cubic meters capacities. Each driver $k$ is assigned to a particular batch plant and is responsible for driving a truck with capacity $Q_k$. The set of drivers is represented by $K =\bigcup_{}K_b $, where $K_b$ is the set of drivers scheduled to start their shift at batch plant $b$. A driver $k$ is required to start his shift at $h_k$, work a minimum of $\mu$ hours and a maximum of $\eta$ hours during regular working hours, with the possibility of overtime of up to $\varLambda$ hours. $\beta_3$ and $\beta_4$ are the penalties for a driver working less than $\mu$ and more than $\eta$.

A driver typically loads RMC at his assigned batch plant but may be required to drive to and load at other plants if needed. The batch plant produces concrete on demand using recipes specific to each order. This means that a truck can only haul RMC for one order, even if there is spare capacity. After unloading the RMC,  driver $k$ takes $\rho$ minutes to clean the concrete mixer before proceeding.


A customer $c$ requests one or more types of concrete to be delivered to their construction site on a specific day, with the delivery service starting at the due time $a_c$. The customer's unloading rate $\tau^u_c$ and the quantity to be unloaded give the time required to unload a truckload. We call an order $o$ a request for a specific type of concrete. Let $q_c$ be the sum of the demands $q_o$ of each order $o$ placed and $a_c$ be the desired arrival time of the first concrete mixer. If an order requires more concrete than a single truck can carry, multiple deliveries are scheduled. We will accept a first delivery if it arrives within a time window of $\left[a_c, a_c + \tau^w_c \right]$, where $\tau^w_c$ is a user-defined parameter. Let $C$ be the set of customers, $O_c$ be the set of all orders requested by customer $c$, and $O=\{O_c, c \in C\}$ be the set of all requested orders for all customers.

Each element of $O_c$ must be entirely delivered before moving on to another order. Exactly one order $o \in O_c$ must have its first delivery start between $\left[a_c, a_c + \tau^w_c \right]$, while the others can start at most $\gamma^2$ time after $o$ is completed. A plant is assigned to an order, and it must supply all of its subsequent deliveries. To avoid cold joint problems with the concrete, subsequent deliveries of the same order must be made in close succession. We define a maximum time delay $\gamma^1$, after which no more deliveries are allowed for the same order.

Let $n_o$ be the number of deliveries needed to fulfill the order $o$. $n_o$ is not known in advance because the trucks have different capacities. However, we can compute a lower $n_o^{min}$ and upper $n_o^{max}$ bounds using the capacities of the largest $Q_{max}$ and smallest $Q_{min}$ available trucks.
\begin{alignat}{3}
    \label{mod:c0}
    n_o^{min} = \left\lceil \frac{q_o}{Q_{max}} \right\rceil \leq n_o \leq n_o^{max} = \left\lceil \frac{q_o}{Q_{min}} \right\rceil & \text{ } &
    \forall  o \in O.
\end{alignat}

Let $d^j_{o}$ be the $j^{th}$ visit with load $q^j_{o}$ for order $o$. We represent the fulfillment of order $o$ by the visits to the ordered set of delivery nodes $D_o= \left(d^1_{o},d^2_{o},\cdots, d^{n_o}_{o}\right)$. The deliveries of customer $c$ are the ordered set $D_c= (D_{o_1}, D_{o_2},\cdots,D_{o_{|O_c|}})$, where $o_r$ is the $r^{th}$ delivered order. We will refer to $d \in D_c$ ($d \in D_o$) as the $d^{th}$ potential delivery of customer $c$ (order $o$). $D=\bigcup_{c\in C} D_c$ is the union of all delivery nodes.

A solution to the problem involves decisions about truck loading schedules, driver assignments to different deliveries, and truck arrival times at construction sites for unloading. For a batch plant, the decision involves choosing which driver to load, when to load them, how much to load, and which construction site to deliver. For a driver, the decision is to determine the sequence of loading depots and delivery sites. And for a construction site, the decision involves determining the arrival times of all scheduled deliveries for the day.

Each driver leaves and returns to their home plant every day. We represent the home plant of a driver $k$ with a starting depot $s_k$ and an ending depot $e_k$. Let $S$ and $E$ be the sets of starting and ending depots, respectively.

We define our problem on a complete directed graph where $V=\{ S \cup L \cup D \cup E\}$ is the set of nodes. The arc sets are $A =  \{(i,j) \hspace*{1mm} \vert \hspace*{1mm} i, j \in V \hspace{1mm}\}$, $A^D = \{(i,j) \hspace*{1mm} \vert \hspace*{1mm} i, j \in D \hspace{1mm} \}$, and $A^L = \{(i,j) \hspace*{1mm} \vert \hspace*{1mm} i, j \in L \hspace{1mm} \}$. $A$ corresponds to allowed movements of drivers from node $i$ to node $j$. For each driver $k$, the allowed movements are the following:
\begin{itemize}
    \item From the starting depot $s_k$ to a loading dock $l \in L$ or to the ending depot $e_k$.
    \item From a loading dock $l \in L$ to a delivery node $d \in D$.
    \item From a delivery node  $d \in D$ to a loading dock $l \in L$ or to the ending depot $e_k$.
\end{itemize}
For a customer $c$, arcs in $A^D$ link consecutive delivery nodes of the same order   $\lbrace (i,j)\in D_o, o \in O_c, i < j  \rbrace$, and pair of delivery nodes of two different orders $ \lbrace (i,d^{0}_{o_2}),  i \in D_{o_1}, i \geq n^{min}_{o_1}, o_1, o_2 \in O_c, o_1 \neq o_2 \rbrace $. Arcs in $A^L$ link all pairs of loading docks of the same batch plant.

We define $\delta^{+}(i) = \{(i, j) \in A \}$ and $\delta^{-}(i) = \{(j, i) \in A \}$ as the outcoming and incoming arc sets of node $i \in V$; $\delta^{+}_D(i) = \{(i, j)  \in A^D\}$ and $\delta^{-}_D(i) = \{(j, i) \in A^D \}$ are the outcoming and incoming arc sets of delivery node $i \in D$.  Similarly, $\delta^{+}_L(i) = \{(i, j)  \in A^L\}$ and $\delta^{-}_L(i) = \{(j, i) \in A^L \}$ are the outcoming and incoming arc sets of loading node $i \in L$. $t_{ij}$ is the time to travel from $i$ to $j$.

Let the binary variable $x^{k}_{ij}$ be $1$ if driver $k$ travels from node $i$ to $j$. Binary variable $y_o$ is $1$ when order $o$ is completely served; $v_i$ and $w_i$ are the start and end of the loading (unloading) operation at node $i \in L\cup D$. Binary variable $u_{ij}$ is $1$ if node $j$ is served just after $i$, the service being either an unloading or a loading operation. Variable $q^k_j$ is the quantity to be loaded towards $j$ with vehicle $k$. Let $w^1_k$ be a continuous variable indicating the difference between the driver's work time and the minimum number of hours to be worked in a day, and $w^2_k$ indicating the difference between the driver's work time and the normal work time. Let $g_i$ be the time between the due date and the first service start for customer $i$.

The objective function minimizes total travel cost ($TC$), penalties associated with unfulfilled orders, first delivery delays ($FDD$), driver underutilization costs ($DUC$), and driver overtime costs ($DOC$). Together, these components drive the optimization process to find a solution that efficiently balances travel costs, customer satisfaction, on-time delivery, driver utilization, and scheduling constraints.

\begin{alignat}{3}
    \label{mod:obj}   \min & \sum_{k \in K}{{ \sum_{ \substack{(i,j) \in A} }} {t_{ij}x^{k}_{ij}}} + \beta_1\smashoperator{\sum_{ o \in O}}{  \left(1-y_o\right)} \hspace{-0mm}  + \beta_2 \smashoperator{ \sum_{i \in C } } { g_i  } +  \sum_{k \in K}\left({\beta_3 w^{1}_k  + \beta_4  w^{2}_k}\right) &                                                                                                  \\
    \label{mod:c1}         & \sum_{j \in \delta^{+}(i) }{x^k_{ij}} =1     & \forall i \in S, k \in K                                                                      \\
    \label{mod:c2}         & \sum_{j \in \delta^{-}(i)}{x^k_{ji}} = 1     & \forall i \in E, k \in K                                                                         \\
    \label{mod:c03}        & v_j \geq  w_i  - M\left(1-x^{k}_{ij}\right)   & \hspace{-20mm}  i \in S, j \in \delta^{+}(i),  k \in K      \\
    \label{mod:c3}         & v_j \geq  w_i + \alpha_{b} + t_{ij} - M\left(1-x^{k}_{ij}\right) & \hspace{-25mm} \forall b \in B, i \in L_b, j \in \delta^{+}(i),  k \in K     \\
    \label{mod:c4}         & v_j \geq  w_i + \rho + t_{ij} - M\left(1-x^{k}_{ij}\right)                                                                       & \hspace{-20mm} \forall i \in D  , j \in \delta^{+}(i), k \in K                         \\
    \label{mod:c5}         & w_{i} \geq v_{i}  + \frac{q^k_j}{\tau^l_b} -M\left(1- x^{k}_{ij}\right)   & \hspace{-25mm} \forall  b \in B,  i \in L_{b},  j \in \delta^{+}(i), k \in K \\
    \label{mod:c6}         & w_{j} \geq v_{j}  + {  \frac{q^k_j}{\tau^u_c} -M\left(1- x^{k}_{ij}\right) }     & \hspace{-25mm}  \forall c \in  C, j \in D_{c}, i \in \delta^{-}(j),  k \in K \\
    \label{mod:c7}         & w_{j} \leq v_{i}  + \Delta + M\left(1- x^{k}_{ij}\right)  & \hspace*{-40mm} j \in D,  i \in \delta^{-}(j),  k \in K \text{ }  \\
    \label{mod:c8}         & v_{d^0_{o}} \geq a_c    & \hspace{-40mm} \forall  c \in C, \forall o \in O_c \text{ }                           \\
    \label{mod:c9}          & g_{c} \geq v_{d^0_{o_1}} - a_c - M\left(  \sum_{ j \in \delta^{-}_{D}(d^0_{o_1})  }{u_{jd^0_{o_1}}}\right)  & \hspace{-40mm}  \forall  c \in C, \forall o_1 \in O_c \text{ }  \\
    \label{mod:c91}  & g_{c} - a_c \leq \tau^w_c  & \hspace{-20mm}  \forall  c \in C \text{ }   \\
    \label{mod:c101}       & v_{d^0_{o_1}} \geq w_j - M\left(1- u_{jd^0_{o_1}}\right)   & \hspace{-50mm}    \forall o_1 \in O_i,  j \in \delta_{D}^{-}(d^0_{o_1}) \text{ }                \\
    \label{mod:c10}        & v_{d^0_{o_1}}  \leq  w_j + \gamma^2 + M\left(1- u_{j,d^0_{o_1}}\right)     & \hspace{-40mm}  \forall  o_1 \in O,  j \in \delta_{D}^{-}(d^0_{o_1}) \text{ }                    \\
    \label{mod:c11}        & \sum_{ \substack{o_1 \in O_c }}{ \sum_{ j \in \delta^{-}_{D}(d^0_{o_1})}}{u_{j,d^0_{o_1} } } = |O_c|-1      & \hspace{-40mm} \forall  c \in C,|O_c| > 1   \text{ }   \\
    \label{mod:c12}        & \sum_{ \substack{o_1 \in O_c }}\sum_{ j \in \delta^{+}_{D}(d^0_{o_1})}{u_{d^0_{o_1},j } } = |O_c|-1      & \hspace{-40mm} \forall  c \in C, |O_c| > 1  \text{ }          \\
    \label{mod:c13}    & \hspace{3mm} \smashoperator{ \sum_{ j \in \delta^{+}_{D}(d^0_{o_1})}}{u_{d^0_{o_1},j } } \leq 1    & \hspace{-20mm}  \forall o_1 \in O \text{ }         \\
    \label{mod:c14}        & \hspace{2mm} \smashoperator{ \sum_{ j \in \delta^{-}_{D}(d^0_{o_1})}}{u_{j,d^0_{o_1} } } \leq 1      & \hspace{-20mm} \forall o_1 \in O \text{ }        \\
    \label{mod:c15}        & \hspace{2mm} \smashoperator{ \sum_{ j \in \delta^{+}_{D}(d^0_{o_1})}}{u_{d^0_{o_1},j } } +\smashoperator{ \sum_{ j \in \delta^{-}_{D}(d^0_{o_1})}}{u_{j,d^0_{o_1} } } \geq 1    & \hspace{-20mm} \forall o_1 \in O \text{ }    \\
    \label{mod:c16}        & v_{j} \geq w_{j-1} - M\left(1- u_{j-1,j}\right)   & \hspace{-40mm}  \forall o \in O, j \in D_{o}, j \geq 1  \text{ }    \\
    \label{mod:c17}        & v_{j}  \leq  w_{j-1} + \gamma^1 + M\left(1- u_{j-1,j}\right)    & \hspace{-50mm} \forall c \in C, \forall o \in O_c, j \in D_{o}, j \geq 1 \text{ }     \\
    \label{mod:c18}        & u_{j-1,j} \geq u_{j,j+1}      & \hspace{-60mm} \forall o_1 \in O,  j \in D_{o_1}, 1 \leq j \leq n_{o_{1}}-1 \text{ }   \\
    \label{mod:c19}        & u_{j-1,j} \geq \sum_{l \in L}{x_{lj}}   & \hspace{-40mm}  \forall o_1 \in O, j \in D_{o_1}, j \geq 1 \text{ }                   \\
    \label{mod:c20}        & v_{j} \geq w_{i} - M\left(1- u_{i,j}\right)   & \hspace{-40mm}  \forall i \in L, j \in \delta^{+}_{L}(i) \text{ }  \\
    \label{mod:c21}        & \hspace{3mm} \smashoperator{ \sum_{ j \in \delta^{+}_{L}(i)}}{u_{i,j } } \leq 1     & \hspace{-40mm}  \forall i \in L \text{ }         \\
    \label{mod:c22}        & \hspace{2mm} \smashoperator{ \sum_{ j \in \delta^{-}_{L}(i)}}{u_{j,i } } \leq 1                                      & \hspace{-40mm} \forall i \in L           \text{ }       \\
    \label{mod:c230}       & \hspace{2mm} \smashoperator{ \sum_{ j \in \delta^{-}_{L}(i)}}{u_{j,i } }  \geq \sum_{k \in K}\sum_{j \in  \delta^{-}(i) }{x^k_{ji}}    & \hspace{-40mm} \forall i \in L \text{ }                                                      \\
    \label{mod:c231}       & \hspace{2mm} \smashoperator{ \sum_{ j \in \delta^{-}_{L}(i)}}{u_{j,i } } \geq \smashoperator{ \sum_{ j \in \delta^{-}_{L}(i+1)}}{u_{j,i+1 } }   & \hspace{-20mm} \forall i \in L  \text{ }                                                        \\
    \label{mod:c23}        & \hspace{2mm} \smashoperator{ \sum_{ j \in \delta^{-}_{L}(i)}}{u_{j,i } } + \smashoperator{ \sum_{ j \in \delta^{+}_{L}(i)}}{u_{i,j } } \geq \sum_{k \in K}\sum_{j \in  \delta^{-}(i) }{x^k_{ji}}    & \hspace{-20mm} \forall i \in L  \text{ }                                                        \\
    \label{mod:c24}        & \sum_{k \in K}\sum_{j \in D_o}{q^k_j} = q_o            & \hspace{-40mm}  \forall o \in O  \text{ }           \\
    \label{mod:c240}       & q^k_j \leq \sum_{i \in  \delta^{-}(j)}{Q^k x^k_{ij}}   & \hspace{-40mm}  \forall j \in D, k \in K  \text{ }                                              \\
    \label{mod:c25}        & \sum_{k \in K}\sum_{j \in \delta^{+}(i)}{x^{k}_{ij} \leq 1}     & \hspace{-40mm} i \in L \cup D       \text{ }          \\
    \label{mod:c26}        & \sum_{k \in K}\sum_{j \in \delta^{+}(i)} {x^{k}_{ij} } =  \sum_{k \in K}\sum_{j \in \delta^{-}(i)}{x^{k}_{ji} }        & \hspace{-40mm}  i \in L \cup D  \text{ }       \\
    \label{mod:c29}        & w^1_k \geq  \mu + h_k - v_{e_k}            & \hspace{-40mm} \forall k \in K   \text{ }         \\
    \label{mod:c30}        & w^2_k \geq (v_{e_k} - h_k) - \eta   & \hspace{-40mm} \forall k \in K         \text{ }         \\
    \label{mod:c31}   & w_{e_k} \leq h_k + \varLambda  & \hspace{-20mm}  k \in K \hspace{0mm}       \text{ }                                            \\
    \label{mod:c32}        & 0 \leq q^k_j \leq Q^k   & \hspace{-40mm}  j \in D, k \in K      \text{ }                                                   \\
    \label{mod:c33}        & x^k_{ij} \in \{0,1\}      & \hspace{-40mm}  (i,j) \in A , k \in K   \text{ }                                            \\
    \label{mod:c34}        & u_{ij} \in \{0,1\}     & \hspace{-40mm}  (i,j) \in A^D \hspace{0mm}   \text{ }                                           \\
    \label{mod:c36}        & y_o \in \{0,1\}     & \hspace{-20mm}  o \in O            \text{ }                     \\
    \label{mod:c37}        & v_i \geq 0,  w_i \geq 0     & \hspace{-20mm}  i \in V         \text{ }                \\
    \label{mod:c38}        & w^1_{k} \geq 0,  w^2_k \geq 0  & \hspace{-20mm}  i \in V         \text{ }        \\
    \label{mod:cend}       & g_c \geq 0    & \hspace{-20mm}  c \in C.  \text{ }
\end{alignat}

$\beta_1$ to $\beta_4$ are the penalty coefficients of each component of the objective function (\ref{mod:obj}). Constraints (\ref{mod:c1}) and (\ref{mod:c2}) state that driver $k$ leaves his start node exactly once a day and returns to his end node. A driver cannot serve a node before the start of his shift with constraints (\ref{mod:c03}). Constraints (\ref{mod:c3}) and (\ref{mod:c4}) set a driver to take some time after loading or unloading to adjust the concrete or clean the truck before moving on to the next node. The duration of the loading operation depends on the plant's loading rate and the amount $q^k_j$ of RMC loaded (\ref{mod:c5}). Similarly, the unloading service depends on the site's rate and $q^k_j$ (\ref{mod:c6}). Unloading operations must end at most $\Delta$ minutes after loading begins (\ref{mod:c7}).

Constraints (\ref{mod:c8}) to (\ref{mod:c10}) ensure that the first service of any customer $c$ must start after the due time $a_c$. This first service may be performed at the first delivery node of any order $\in O_c$, and one order must be completed before another is started. It also enforces the precedence constraints between the last delivery of an order and the first delivery of the following order.
Constraints (\ref{mod:c11}) to (\ref{mod:c15}) find the delivery sequence of all orders $\in O_c$. With constraints (\ref{mod:c16}) -- (\ref{mod:c19}), two trucks cannot unload at the same time for consecutive deliveries of the same order. Additionally, these constraints impose a maximum time delay between the two trucks. Similarly, constraints (\ref{mod:c20}) -- (\ref{mod:c23}) ensure that two trucks cannot be loaded at the same time at a plant. Constraints (\ref{mod:c24}) require that the cumulative load of all concrete mixers serving an order must equal the required quantities, and (\ref{mod:c240}) bound a driver load. Constraints (\ref{mod:c25}) require a driver to only visit a loading/delivery node once. Constraints (\ref{mod:c26}) are degree constraints. Constraints (\ref{mod:c29}) -- (\ref{mod:c30}) calculate the difference between a driver's hours of service and the minimum and normal hours of service. Finally, constraints (\ref{mod:c31}) to (\ref{mod:cend}) define the nature and bounds of the variables.

Figure~\ref{fig:plants_schedules} presents a solution for an instance. The instance has two plants, nine drivers, and five customers, with two customers having multiple orders. Customer $4$ has two orders ($o_4$--$o_5$) assigned to plant $1$, and customer $5$ has three orders ($o_{6}$--$o_{8}$) assigned to plant $2$. All the order requirements are in the Table~\ref{tab:instance_detail}. Figure \ref{fig:plants_schedules} provides a visual representation using a Gantt chart of the loading and unloading operations performed by the drivers at each plant. The light gray, dark gray and black colors represent a customer's first, second and third order. We can see that the loading operations for each plant do not overlap, and the unloading operations occur sequentially, one after the other, at each worksite. At plant $1$, loading operations for $C3$ are performed first by drivers $3,5,4,2$ followed by loadings for  $C1$. The second order of $C5$ is delivered, followed by the second, and finally, the first order. All first deliveries start at their due time, except for $C2$, which is 20 minutes late. There is a delay between each delivery of $C2$. However, it is less than the maximal time delay of 25 minutes defined for this example. We can see that some drivers load at both plants. For example, driver $5$ loads at plant $1$ to perform the second delivery of $C3$ then drives to plant $2$ for the first delivery of $C2$. Driver $1$ is originally assigned to plant $1$ but starts his first service at $2$ before returning to his home plant. The loadings at plant $2$ show how the loading dock is alternately assigned for orders of customers $2,4$ and $5$ between $06\text{:}25$ and $10\text{:}00$. We obtain this solution using a heuristic solution approach that we describe next.

\begin{table}[!ht]
    \centering
    \caption{Informations of the illustration instance}
    \label{tab:instance_detail}
    \resizebox*{0.8\textwidth}{!}{
        \begin{tabular}{@{}c|cccccccccccccc@{}}
            \toprule
            Order         & 1     & 2     & 3     & 4     & 5     & 6     & 7     & 8       \\ \midrule
            Customer      & 1     & 2     & 3     & 4     & 4     & 5     & 5     & 5       \\
            \midrule
            Demand   & 24   & 32   & 36   & 40   & 16  & 20  & 32  & 8 \\
            \midrule
            Plant    & 1     & 2     & 1     & 2     & 2    & 2  &  2 & 2     \\
            \midrule
            TW       & 08:45 & 08:00 & 07:00 & 07:00 & 07:00 & 06:50 & 06:50 & 06:50  \\ \bottomrule
        \end{tabular}
    }
\end{table}

\begin{figure}[htb]
    \centering
    \caption{Gantt chart of the loading and unloading operations of the illustration instance}
    \label{fig:plants_schedules}
        \includegraphics[width=\linewidth]{exemple.pdf}
\end{figure}

\section{Constructive heuristics and GRASP}
\label{sec:cdp_grasp_method}

This section presents the heuristic approach to solving the Concrete Delivery Problem. Our method consists of constructing feasible solutions of the CDP with randomized greedy heuristics and iteratively invoking these heuristics in the GRASP metaheuristic. From now on, we represent the scheduling of a delivery node $d$ as the pair ($L^k_{d}$,$U^k_{d}$) of loading and unloading tasks. $L^k_{d} = \left(b,q_d,v_b,w_b\right)$ indicates that driver $k$ will load $q_d$ $m^3$ of RMC at plant $b$ between timeslot $\left[v_b,w_b\right]$ to serve $d$. $U^k_{d} = \left(k,v_d, w_d\right)$ indicates that driver $k$ will start unloading at time $v_d$ and finish at time $w_d$. We then call a solution $Sol =\left\lbrace \cup _{1 \leq j \leq |D|} (L^k_{j}, U^k_{j}), k \in K \right\rbrace$ the set of all pairs of loading and unloading tasks performed on a given day.

\subsection{GRASP algorithm}

The Greedy Randomized Search Procedure (GRASP) algorithm is a multi-start metaheuristic for combinatorial optimization problems proposed by \cite{feo1989probabilistic}. It is a two-phase iterative sequence of constructive and local search algorithms. A feasible solution is generated in the construction phase using a greedy randomized algorithm. Then, the local search phase tries to improve it. Algorithm~\ref{alg_grasp} outlines the GRASP algorithm. We start with a list of greedy randomized heuristics and iterate on each to construct an incumbent solution $Sol$ on which we apply a local search procedure to explore its neighborhood. The best solution found so far is then stored. To avoid redundant computations, a hash table $T$ ensures that the local search is not applied twice to the same solution. The procedure stops and returns the best overall solution when certain stopping conditions are met, such as reaching a time limit or a maximum number of iterations. 
    \begin{algorithm}[hbpt]
        \caption{Pseudo-code of the GRASP algorithm }
        \label{alg_grasp}
        \DontPrintSemicolon
        \LinesNumbered
        \setcounter{AlgoLine}{0}
        \KwIn{ \textit{H}: List of constructive greedy randomized heuristics }
        $Sol^{*} \leftarrow \emptyset$    \hspace{2mm}        $Cost(Sol^*) \leftarrow \infty$

        Initialize an empty hash table $T \leftarrow \emptyset$

        % $counter \leftarrow  0$

        \While{conditions not met}{

            \ForEach{$heuristic \in H$}{
                $Sol \leftarrow heuristic()$

                \uIf{ $Sol \notin T$}{
                    $Sol \leftarrow LocalSearch(Sol)$

                    Add $Sol$ to $T$

                    \uIf{$Cost(Sol)< Cost(Sol^*)$}{
                    $Sol^* \leftarrow Sol$
                    }
                }
            }
        }

        \KwRet{$S^{*}$}
    \end{algorithm}
            
For the construction phase, we developed two greedy randomized heuristics: the customer-based insertion with backtracking, which schedules customers one at a time, and the delivery-based insertion.%, which does not necessarily complete the scheduling of one customer before starting to schedule another.
% The greedy aspect of GRASP is the creation of the set $RCL$, the probabilistic aspect is the random selection in $RCL$, and the adaptive aspect is the updating of $CL$ and the re-evaluation of the incremental costs.

\subsection{Customer-based insertion with backtracking heuristic}

The customer-based insertion heuristic builds a solution from scratch by iteratively scheduling one customer at a time. When a customer is selected, all deliveries needed to serve that customer are scheduled before moving on to the next customer. As shown in Algorithm~\ref{alg:greedyCustIns}, between lines $4$ and $38$, we iterate over a shuffled list of orders for each customer.

To schedule an order $o$, we begin with its first delivery node. Once this node is scheduled, we proceed to schedule the subsequent delivery nodes until $o$ is completely served. For each delivery node $d$, the algorithm identifies between lines $9$ and $12$ each driver capable of visiting this node using the $SimulateVisit$ procedure. For all drivers able to serve $d$, at line $12$ we store the details about the pair of loading and unloading tasks and its cost in $M[d]$.

If at least one driver can serve the node (line $13$), we randomly select at line $16$  a pair of loading and unloading tasks whose cost falls within a specified range based on a parameter $\theta$ and insert this pair into $Sol$ at line $18$. Then we update the order remaining demand and proceed with the next delivery node at line $19$. 

In cases where no driver can visit the node $d$, the algorithm employs a backtracking scheme to address two distinct scenarios. First, if the visit to $d$ cannot be scheduled due to cold-joint constraints (i.e. the time between consecutive deliveries exceeds $\gamma^1$), the $DelayPreviousDelivery$ procedure is employed. This procedure determines if a previous delivery $D^{j'}_o$ of the same order exists such that $d$ can be successfully scheduled in the current solution by delaying the start of service of $D^{j'}_o$ by $\lambda$. If $D^{j'}_o$ exists, the schedules of all delivery nodes between $D^{j'}_o$ and $d$ are removed, and the scheduling of order $o$ resumes from $D^{j'}_o$. 

In cases where infeasibility arises from other violated constraints, the algorithm attempts to backtrack to a precedent node and retry the scheduling with another driver. At line $31$, the algorithm searches for the first precedent node $D^{j'}_o$ with remaining pair of tasks in $M[D^{j'}_o]$. If found, the schedules of all delivery nodes between $D^{j'}_o$ and $d$ are removed, and backtracking occurs to $D^{j'}_o$. In this iteration, since $M[D^{j'}_o]$ is not empty, the $SimulateVisit$ procedure is not called again; instead the stored elements of $M[D^{j'}_o]$ are utilized.

If no precedent node suitable for backtracking is found, it indicates that the current customer cannot be scheduled. Consequently, all previously scheduled visits to its delivery nodes are removed before advancing to the next customer (as described in lines $23$--$25$ and lines $32$--$34$). The procedure stops when all customers are evaluated and returns the constructed solution $Sol$ at the end.

The procedure $DelayPreviousDelivery$ computes the difference $\lambda$ between the earliest time a driver can visit $D^{j}_o$ and the end of service of its immediate predecessor node $D^{j-1}_o$. Then, it tries to find one of the precedent nodes of $D^{j}_o$ for which we can delay the start of service of at least $\lambda = min(\lambda,\gamma^1)$. If such a node exists, the procedure returns it and the value of the delay. Then we backtrack to this node and restart the scheduling process.

The $SimulateVisit$ procedure takes a partial solution, a delivery node $d$, a driver $k$ and the delay value $\lambda$ as parameters. Its goal is to find the earliest time when the loading service for $d$ can start at its home plant $b$. When planning to visit delivery node $d$ of order $o$ and customer $c$ with driver $k$, we first compute his delivery time $v_d$ as follows. If $d$ is the first  visited node of customer $c$, then we expect its service to start at $v_d = a_c + \lambda$. Otherwise, if the previous node $j$ visited before $d$ belongs to the same order $o$, then the service at $d$ may begin at the random value $w_j + rand(\lambda, \gamma^1)$ to respect the allowed time between two consecutive deliveries of the same order. We randomize $v_d$ to allow more diversity in our solution space. Finally, if $j$ and $d$ belong to different orders, then $v_d = w_j + rand(0,\gamma^2)$.

Let $\bar{q}_o$ be the remaining demand of order $o$. Driver $k$ can supply $d$ with the quantity $q^k_d= \min(\bar{q}_o,Q^k)$. We determine the loading start time $v_l$ of the corresponding dock node $l$ by subtracting the travel time, adjustment time, and loading duration from $v_d$: $w_l = v_d - t_{dl} - \alpha_b - q^k_{d}/\tau^l{_b} $. If $j$ is the last node where $k$ was unloading with a service duration $s_j$, then $w_l= \max(w_l, v_j + s_{j} + t_{jl})$. Now, we have the earliest time $k$ can start loading at plant $b$, but if the loading dock is occupied at that time, $k$ will have to wait. To find the real loading time, we use a data structure that stores all timeslots when a plant is occupied. Then, starting from $w_l$, we search forward for the first timeslot with duration $q^k_{d}/\tau^l{_b}$ where we can insert this loading operation and update $w_l$ accordingly. Changing $w_l$ can cause violations of the time window or cold-joint constraints, especially for an order's subsequent deliveries, and thus make the schedule infeasible. So with this new value of $w_l$, we recompute $v_l$ and check for constraint violations.

Algorithm~\ref{alg:greedyCustIns} is designed with a list of customers as input. Initial experimentation has revealed that the sequence of this list affects the final solution. Within the GRASP framework, we invoke the customer-based heuristic multiple times with various customer orderings. These include sorting by decreasing demand and time window, sorting by increasing demand and time window, and finally, with a randomized list.
    \begin{algorithm}[!ht]
        \caption{Customer-based insertion algorithm }
        \label{alg:greedyCustIns}
        \DontPrintSemicolon
        \LinesNumbered
        \setcounter{AlgoLine}{0}
        \KwIn{  $Sol$: empty solution, $K$: vehicles set, $\Pi$: list of customers }

        $M \leftarrow \emptyset $ \tcp{List of pairs of loading and unloading tasks for each delivery node}

        \ForEach{$c \in \Pi$}{

            Shuffle $ O_c$

            \ForEach{$o \in O_c$}{

                $\lambda \leftarrow 0$, $\bar{q}_o\leftarrow q_o$, $j \leftarrow 1$

            \While{$\bar{q}_o>0$}{

                $d \leftarrow D^j_{o}$

                \uIf{($M[d] = \emptyset $) or ($\lambda >0$)}{

                    \ForEach{ $k \in K$  }{

                        $(L^k_{d}$, $U^k_{d},cost,f)$ $\leftarrow $ SimulateVisit($Sol$,$d$,$k$,$\lambda$)

                        \uIf{f=1}{
                                $M[d] \leftarrow M[d] \cup \{(L^k_{d}, U^k_{d},cost,k)\}$ 
                            }
                    }
                }

                \uIf{$M[d]\neq \emptyset$}{

    $c_{min} \leftarrow \min\left\{ cost \ | \ (L^k_{d}, U^k_{d},cost,k) \in M[d]   \right\} $

    $c_{max} \leftarrow \max\left\{ cost \ | \ (L^k_{d}, U^k_{d},cost,k) \in M[d]   \right\} $
    
    Randomly choose $(L^k_{d}, U^k_{d},cost,k)$ in $M[d]$ such that $cost \leq c_{min} + \theta (c_{max}-c_{min}) $

    $M[d]\leftarrow M[d] \backslash \{(L^k_{d}, U^k_{d},cost,k)\} $
    
    $Sol \leftarrow Sol \cup \{(L^k_{d}$, $U^k_{d})\}  $

        $\bar{q}_o \leftarrow \bar{q}_o-q^k_{d}$, $\lambda \leftarrow 0$, $j \leftarrow j+1$

    }
    \uElse{
        \uIf{cold-joint constraints}{
            $(D^{j'}_o,delay)$ = $DelayPreviousDelivery$($Sol$,$d$) \tcp{$j'<j$}

        \uIf{no $D^{j'}_o$ exists}{

            $Sol \leftarrow Sol \backslash \{(L^k_{i}, U^k_{i}), \forall i \in D_c\}$

            Go to line 2 \tcp{continue with next customer}
}

$Sol \leftarrow Sol \backslash \{(L^k_{i}, U^k_{i}), \forall i \in (D^{j'}_{o},..,D^{j-1}_{o})  \}$

Update $\bar{q}_o$

$j \leftarrow j'$, $\lambda \leftarrow delay$

    Go to line 6 \tcp{backtrack to $j'$ position and retry to insert $D^{j'}_{o}$}
    }
    \uElse{
     Search for a precedent delivery node $D^{j'}_o, j'<j$ with $M[D^{j'}_o]\neq \emptyset$

    \uIf{ no $D^{j'}_o$ exists}{

    $Sol \leftarrow Sol \backslash \{(L^k_{i}, U^k_{i}), \forall i \in D_c\}$

    Go to line 2 \tcp{continue with next customer}
    }

    $Sol \leftarrow Sol \backslash \{(L^k_{i}, U^k_{i}), \forall i \in (D^{j'}_{o},..,D^{j-1}_{o})  \}$

    Update $\bar{q}_o$

     $j \leftarrow j'$

    Go to line 6 \tcp{backtrack to precedent delivery node $D^{j'}_o$ }
                        }

                    }
                    
                }
            }
        }
        \KwRet{$Sol$}
    \end{algorithm}

When confronted with scenarios where several customers require their services to start simultaneously or within the same time window, we observed that Algorithm~\ref{alg:greedyCustIns} may leave some customers remain unscheduled when resources are limited. To address this limitation, we introduce the delivery-based insertion heuristic.

\subsection{Delivery-based insertion heuristic}

The delivery-based insertion heuristic (Algorithm~\ref{alg:delbasedIns}) iteratively constructs a solution from scratch by scheduling one delivery node at a time. The algorithm starts with an empty solution $Sol$ and initially fills a candidate list $CL$ with the first node of a randomly selected order for each customer. Within each iteration of the $while$ loop, the algorithm filters $CL$ to obtain a reduced candidate list $CL'$ of deliveries based on a specified criterion, such as prioritizing deliveries with the highest (lowest) demands, earliest (latest) due dates, or lowest order numbers. This filtering is performed by the $Filter$ procedure, allowing the algorithm to explore different neighborhoods. Thus, within the GRASP framework, we can invoke the delivery-based heuristic multiple times with different filtering procedures which evaluate different neighborhoods. 

Between lines $14$ and $18$, for each delivery $d$ in $CL'$, the algorithm determines the best available driver $k$ who can visit it. Then, the corresponding pair of loading and unloading tasks $(L^k_d, U^k_d)$, along with its costs, are stored in $M[d]$. This is done using the $SimulateVisit$ procedure described earlier. Then, the algorithm constructs at line $20$ a list $T$ containing all pairs of loading and unloading tasks for the delivery nodes in $CL'$.

If $T$ is empty, the algorithm assumes that the customers associated with the nodes in $CL'$ cannot be scheduled, and it removes those customers' existing schedules from the solution. It then excludes $CL'$ from $CL$ at line $25$ and proceeds to the next iteration.

Otherwise, from line $26$ to line $29$, the algorithm randomly selects from $T$ a pair of loading and unloading tasks whose cost falls within a specified range determined by the parameter $\theta$ and inserts this pair into $Sol$. The algorithm then updates the remaining orders and customer quantities and excludes the scheduled delivery node from $CL$. If an order $o$ is not completely fulfilled after visiting $d^j_{o}$, the next delivery node $d^{j+1}_{o}$ is added to $CL$.  Otherwise, if the customer has remaining orders, the first delivery node $d^{1}_{o'}$ of another randomly selected order $o'$ is added to $CL$.

Unlike the customer-based insertion, the delivery-based insertion allows each customer to have one of its delivery nodes considered for scheduling at each iteration.
%In these two heuristics, the greedy aspect of GRASP refers to the creation of the set $RCL$, the probabilistic aspect is the random selection in $RCL$, and the adaptive part is the updating of $CL$ and the re-evaluation of the costs.
 
\begin{algorithm}[!ht]
    \caption{Delivery-based insertion algorithm }
    \label{alg:delbasedIns}
    \DontPrintSemicolon
    \LinesNumbered
    \setcounter{AlgoLine}{0}
    \KwIn{  $Sol$: empty solution, $\Pi$: list of customers, $Filter$: filtering procedure}

    $CL \leftarrow \emptyset$

    $M \leftarrow \emptyset $ \tcp{List of pairs of loading and unloading tasks for each delivery node}

    $\bar{q} \leftarrow \emptyset$ \tcp{List of remaining demands}

    \ForEach{$c \in \Pi$}{
        $\bar{q}_c \leftarrow q_c$

        Select a random order $o \in O_c$

        $CL \leftarrow CL \cup \{d^1_{o}\}$

        $\bar{q}_o \leftarrow q_o$
    }

    \While{$CL \neq \emptyset$}{

        $CL' \leftarrow \text{} Filter (CL) $

        $T \leftarrow \emptyset $ \tcp{List of loading and unloading tasks}

        \ForEach{ $d \in CL'$}{

            $best\_cost \leftarrow +\infty$

            \ForEach{ $k \in K$  }{

                $(L^k_{d}$, $U^k_{d},cost,f)$ $\leftarrow $ SimulateVisit($Sol$,$d$,$k$,$\lambda$)

                \uIf{f=1 and $cost <       best\_cost$}{
                    $M[d] \leftarrow \{(L^k_{d}, U^k_{d},cost,k)\}$ 

                    $best\_cost \leftarrow c$
                }
            }

            \uIf{$M[d]\neq \emptyset$}{
                $T \leftarrow T \cup M[d]$    
            }
        }
        \uIf{$T = \emptyset$}{
            \ForEach{$d \in CL'$}{
            
           $c \leftarrow $ customer associated with $d$

            $Sol \leftarrow Sol \backslash \{(L^k_j,U^k_j), \forall j \in D_c \}$
           }
           $CL \leftarrow CL\backslash CL'$ 
        }
        \uElse{
            $c_{min} \leftarrow \min\left\{ cost \ | \ (L^k_{d}, U^k_{d},cost,k) \in T   \right\} $

            $c_{max} \leftarrow \max\left\{ cost \ | \ (L^k_{d}, U^k_{d},cost,k) \in T   \right\} $
    
            Randomly choose $(L^k_{d^j_o}, U^k_{d^j_o},cost,k) \in T$ such that $cost \leq c_{min} + \theta (c_{max}-c_{min}) $
            
            $Sol \leftarrow Sol \cup \{(L^k_{d^j_o}$, $U^k_{d^j_o})\} $

            $\bar{q}_o \leftarrow \bar{q}_o-q^k_{d^j_o}$, $\bar{q}_c \leftarrow \bar{q}_c-q^k_{d^j_o}$ \tcp{$o \in O_c$}

            $CL \leftarrow CL \backslash \{d^{j}_o\}$

            \uIf {$\bar{q}_{o} \neq 0$ }{

                $CL \leftarrow CL \cup \{d^{j+1}_{o}\}$
            }
            \uElseIf{ $\bar{q}_c \neq 0$}{

                Select another order $o' \in O_c$

                $CL \leftarrow CL \cup \{d^{1}_{o'}\} $
            }

        }      
    }
        \KwRet{$Sol$}
\end{algorithm}

\subsection{Local Search}

After the construction phase, the local search phase invokes local search operators to either repair or improve the incumbent. One operator is used to repair a solution where not all customers are scheduled. Then four operators are used to improve the incumbent using a first-improvement strategy. The local search continues until no more improvements can be made or a timeout is reached. 

\subsubsection{Repair operator}

The Remove and Reschedule operator is used to address situations where a solution contains unscheduled customers. This operator first selects an unscheduled customer $c$ from the solution and identifies a set $\Pi_c$ containing scheduled customers sharing the same time slot with $c$. The schedules of all elements of $\Pi_c$ are then removed from the solution and retried to be scheduled again along with $c$. 

\subsubsection{Improvement operators}

The first improvement or Load Backward operator is used when dealing with solutions containing customers whose first delivery is late. In such cases, the goal is to schedule the loading start time for the first delivery node for these customers as early as possible. This operator is implemented by iterating backward through the timeslots data structure when calculating the loading start time within the $SimulateVisit$ procedure. By doing so, the operator aims to find a loading start time that allows for earlier delivery, thus reducing the late first delivery cost. The other improvement operators are based on the swap and relocate moves. 

We have implemented two moves based on the swap operator. The Swap Driver operator explores alternative driver assignments by swapping drivers assigned to two delivery nodes. This allows for the assessment of different driver configurations, potentially leading to improvements in solution quality. The Swap Load operator exchanges loads between a delivery node and the last delivery node of the same order. In our greedy randomized heuristics, all deliveries of an order are typically filled to capacity, except for the last one.  This operator investigates the effect of delivering this last load much earlier in the delivery sequence. Delivering the final load earlier in the sequence can improve the loading operations, as it may be easier to find an empty timeslot for inserting a loading task with a smaller load. 

We also implemented two moves based on the relocate operator. The Consolidate Load operator is applied on an order with a remaining demand between $]Q_{min},Q_{max}]$. If this remaining demand is served with two drivers with capacity $Q_{min}$, then the operator tries to consolidate it to be served by a single driver with a capacity of $Q_{max}$. Next, the Relocate Driver operator removes a delivery node from its current route and inserts it in another driver's route. This enables the redistribution of delivery nodes among drivers, potentially reducing drivers underutilization and overtime costs.

\section{Computational experiments}
\label{sec:cdp_comp_exp}

In this section, we present and discuss the results of computational experiments conducted using the GRASP heuristic described in Section~\ref{sec:cdp_grasp_method}. The implementation of the GRASP algorithm is coded in C++. We run our experiments on the benchmark data used in \cite{kinable2014concrete}, and on a new dataset extracted from delivery operations records provided by our industry partner.

\subsection{Generation of instances}
\newcommand{\nbInstance}{36}
The dataset used in this section was obtained from our partner and contains records representing delivery operations from up to 8 production centers for $\nbInstance$ days. From this historical data, we extracted information such as daily orders delivered, plant assignments to orders, and the number of available drivers. We created $\nbInstance$ instances from this data, where each instance corresponds to a daily operation. To maintain confidentiality, we have removed the GPS coordinates of customers and plants but have included two matrices containing the distances and driving times between all plants and customers. An instance contains information such as each driver's capacity, associated batch plant, and shift start time (which we generate). For each customer, we have the due time, the total demand, the number of orders (type of concrete) received, and its index in the time (distance) matrix. For each order, we have its demand and the corresponding production plant. Finally, we have the loading capacity for each plant, as well as its index in the time matrix. The name of an instance has the format $C\_n\_o\_k\_z$, where $n$ is the number of customers, $o$ is the total number of daily orders, $k$ is the number of available drivers, and $z$ is the number of plants. The dataset is divided into small, medium, and large sets according to the total number of daily orders. We have summarized the dataset in Table~\ref{tab:cdp_instances}. The small dataset has eight files with four to eleven customers whose demands vary between 226.5 and 937.5 m$^3$. These customers request between 7 and 14 orders, which are served from one to three depots with a fleet of 13 to 35 concrete mixers. The dataset is available upon request as a contribution to the CDP literature.
\begin{table}[htpb]
    \centering
    \caption{Instances summary}
    \label{tab:cdp_instances}
    % \small
    \resizebox*{0.9\textwidth}{!}{
        \begin{tabular}{lcccccc}
            \toprule
            {}     & \# & Demand (m$^3$)           & \#Order   & \#Client & \#Driver & \#Depot \\
            \midrule
            Small  & 8  & 226.5 - 937.5     & 7 - 14    & 4 - 11   & 13-35    & 1-3     \\
            Medium & 14 & 1,160.5 - 2,971.0 & 43 - 98   & 40 - 89  & 76-137   & 6-8     \\
            Large  & 14 & 3,078.5 - 3,953.5  & 107 - 136 & 92 - 127 & 129-150  & 8       \\
            \bottomrule
        \end{tabular}
    }
\end{table}

\subsection{Results for the instances of \cite{kinable2014concrete}}

\cite{kinable2014concrete} provided a benchmark dataset for their variant of the CDP. Although their primary objective is to maximize the total load delivered each day without considering loading operations at a plant and ensuring deliveries within specified time windows, we still use this dataset to analyze and compare the performance of our algorithm under different conditions. \cite{kinable2014concrete} solved their problem with a CP algorithm, MIP, steepest descent heuristic (SD), and fix-and-optimize MIP heuristic (MIP fix \& opt), which is a hybridization of the MIP and SD. They also provide upper bounds to help assess the optimality of the instances. Table \ref{tab:cdp_lit_comp} shows the performance of the GRASP heuristic against the methods mentioned above. For each method, the table shows the average execution time in seconds and the corresponding gap between the obtained solution and the upper bound provided by \cite{kinable2014concrete}. The row Opt reports the number of optimal solutions found by each methods.

\begin{table}[htbp]
    \centering
    \caption{Performance of the GRASP heuristic on the CDP benchmark instances}
    \label{tab:cdp_lit_comp}
    \scriptsize
    \resizebox{1\textwidth}{!}{
        \begin{tabular}{@{}cccccccccc|cc@{}}
            \toprule &     & \multicolumn{2}{c}{CP}     & \multicolumn{2}{c}{MIP}   & \multicolumn{2}{c}{SD-heuristic} & \multicolumn{2}{c}{MIP fix \& opt} & \multicolumn{2}{|c}{GRASP}                                                 \\ \cmidrule(l){3-10} \cmidrule(r){11-12}
               &     & Gap (\%)                   & Time (s)                 & Gap (\%)                         & Time (s)                  & Gap (\%)                   & Time (s) & Gap (\%) & Time (s) & Gap (\%) & Time (s) \\ \cmidrule(l){3-10} \cmidrule(l){11-12}
            \multirow{2}{*}{Set A} & Avg & 4.2                        & 196.95                  & 7.3                              & 149.14                 & 9.1                        & 0.02        & 7.0      & 100.70   & 5.7      & 13.18    \\ \cmidrule(l){2-10} \cmidrule(r){11-12}
                & Opt & \multicolumn{2}{c}{40/64}  & \multicolumn{2}{c}{37/64} & \multicolumn{2}{c}{30/64}        & \multicolumn{2}{c|}{35/64}  & \multicolumn{2}{c}{35/64}                                                            \\ \cmidrule(l){3-10} \cmidrule(r){11-12}
            \multirow{2}{*}{Set B} & Avg & 12.1                       & 355.95                   & -                                & -                          & 16.3                       & 1.33     & -        &  \multicolumn{1}{c|}{-}         & 13.8     & 574.98   \\ \cmidrule(l){2-10} \cmidrule(r){11-12}
              & Opt & \multicolumn{2}{c}{55/128} & \multicolumn{2}{c}{-}     & \multicolumn{2}{c}{40/128}       & \multicolumn{2}{c|}{-}      & \multicolumn{2}{c}{44/128}                                                           \\ \bottomrule
        \end{tabular}
    }
\end{table}

Overall, the GRASP algorithm shows its effectiveness in providing near-optimal solutions in a relatively short time for this benchmark of the CDP, making it a suitable candidate for further analysis and real-world application.  It outperformed all methods except CP, achieving an average gap of 5.7\% (13.8\%) with a runtime of 13 (575) seconds for Set A (Set B). The SD-heuristic appears to be much faster (23 milliseconds for set A), but GRASP provides a better balance between solution quality and computation time. It should also be noted that the exact MIP, CP, and MIP fix \& opt are initialized with the results of the SD-heuristic.

\subsection{Results for the generated instances}

The computational results of our instances solved with the GRASP heuristic are summarized in the tables below. The parameters used in our experiments are listed in Table~\ref{tab:cdp_problem_parameters}.

\begin{table}[!ht]
    \centering
    \caption{Parameters of the real-world instances}
    \label{tab:cdp_problem_parameters}
    \small
    \begin{tabularx}{\textwidth}{Xr}
        \toprule
        \multicolumn{1}{c}{Parameter}  &
        \multicolumn{1}{c}{Value} \\ \midrule
 Time window ($\tau^w$)  & 60 min    \\
 Unloading duration ($\tau_c^u$)  & 2 min$/m^3$   \\
 Cleaning duration ($\rho$)    & 10 min  \\
        Adjustment duration ($\alpha$)                                                & 10 min                    \\
        Max travel time ($\Delta$)                                                    & 120 min                   \\
        Min working time ($\mu$)                                                      & 180 min                   \\
        Max working time ($\eta$)                                                      & 480 min                   \\
        Max overtime duration ($\varLambda$)                                                 & 120 min                   \\
        Max delay between two consecutive deliveries of the same order $\gamma^1$)   & 20 min                    \\
        Max delay between two consecutive deliveries of different orders ($\gamma^2)$ & 25 min                    \\
        Penalty of unfulfilled orders ($\beta_1$)                                     & 100,000                   \\
        Penalty of first delivery delay ($\beta_2$)                                   & 10,000                    \\
        Penalty for driver underutilization  ($\beta_3$)                              & 30                        \\
        Driver overtime penalty $ (\beta_4$)                                          & 20                        \\
        \bottomrule
    \end{tabularx}
\end{table}

Table \ref{tab:cdp_all_instances} contains the detailed results for all instances with a stop criterion of 3600 seconds. The table shows the demand of each instance, the average, and the best values of the objective function when solving each instance five times. All daily orders of the small instances are completely served by our algorithm within these five iterations, as shown in column $UQ$, which reports the undelivered quantities. For the medium and large instances, $99.57\%$ and $99.5\%$ of the total demands are delivered. The sum of driver underutilization costs ($DUC$) is high for medium and large instances. This indicates the underutilization of the scheduled fleet. Some drivers are not scheduled at all or work very little. The sum of driver overtime costs ($DOC$) is also high for these instances. This can be explained by the fact that the algorithm prefers to put drivers on overtime rather than use a driver who has to travel to another plant for a delivery, which would increase travel costs ($TC$).

$FDD$ represents the sum of the delays of the first deliveries. In the case of small instances, all but one of the first deliveries are on time. However, for the other instance sets, there is at least one customer with a late first delivery. To provide insight into the actual delay experienced by customers, we report $mFDD$, which is the maximum delay among all first deliveries. This information reveals that for small instances, the maximum delay ranges between 0 and 35.7 minutes. For medium instances, it varies from 16.8 to 60 minutes, and for large instances, it falls within the range of 56 to 60 minutes.

\begin{table}[ht!]
    \centering
    \caption{Results with all instances}
    \label{tab:cdp_all_instances}
    \resizebox{\textwidth}{!}{
    \begin{tabular}{lcccccccccccccccccc}
    \toprule
     &  &  &  &  & \multicolumn{6}{c}{Avg} & \multicolumn{6}{c}{Best}  \\
    \cmidrule(l){7-12} \cmidrule(l){13-19}
     &  &  &  &  & Demand & $TC$ & $UQ$ & $FDD$ & $DUC$ & $DOC$ & \multirow[c]{2}{*}{Z}  & $TC$ & $UQ$ & $FDD$ & $mFDD$ & $DUC$ & $DOC$ & \multirow[c]{2}{*}{Z}  \\
      & |$C$| & $|O|$ & $|K|$ & $|B|$ & (m$^3$) & (min) & (m$^3$) & (min) & (min) & (min) &  & (min) & (m$^3$) & (min) & (min) & (min) & (min) &  \\
    \midrule
    \multirow[c]{8}{*}{Small} & 11 & 12 & 13 & 1 & 226.5 & 1,243.5 & 0.0 & 0.0 & 10.8 & 0.0 & 1,568.3 & 1,243.5 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 1,243.5 \\
     & 5 & 8 & 13 & 1 & 267.0 & 745.1 & 0.0 & 0.0 & 0.0 & 0.0 & 745.1 & 745.1 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 745.1 \\
     & 6 & 11 & 18 & 2 & 333.5 & 753.3 & 0.0 & 0.0 & 145.9 & 0.0 & 5,130.0 & 753.3 & 0.0 & 0.0 & 0.0 & 118.7 & 0.0 & 4,315.1 \\
     & 4 & 7 & 15 & 2 & 375.0 & 1,015.6 & 0.0 & 0.0 & 148.2 & 150.5 & 8,470.9 & 1,015.4 & 0.0 & 0.0 & 0.0 & 123.4 & 110.3 & 6,924.5 \\
     & 7 & 8 & 19 & 2 & 388.0 & 1,747.2 & 0.0 & 0.0 & 349.8 & 159.0 & 15,421.6 & 1,781.8 & 0.0 & 0.0 & 0.0 & 186.0 & 0.0 & 7,361.5 \\
     & 10 & 14 & 29 & 3 & 613.5 & 3,510.1 & 0.0 & 59.5 & 194.6 & 331.9 & 75,488.1 & 3,493.4 & 0.0 & 59.5 & 35.7 & 120.5 & 60.0 & 67,810.4 \\
     & 8 & 11 & 31 & 3 & 776.0 & 2,314.8 & 0.0 & 0.0 & 804.3 & 640.7 & 39,256.8 & 2,278.2 & 0.0 & 0.0 & 0.0 & 503.5 & 617.0 & 29,722.9 \\
     & 9 & 10 & 35 & 3 & 937.5 & 4,175.5 & 0.0 & 0.0 & 222.1 & 669.3 & 24,224.7 & 4,163.1 & 0.0 & 0.0 & 0.0 & 243.3 & 570.0 & 22,863.2 \\
     \cmidrule(l){1-12} \cmidrule(l){13-19}
     \multicolumn{5}{r}{Average} & - & 1,938.1 & 0.0 & 7.4 & 234.4 & 243.9 & 21,288.2 & 1,934.2 & 0.0 & 7.4 & 4.5 & 161.9 & 169.6 & 17,623.3 \\
     \cmidrule(l){1-12} \cmidrule(l){13-19}
     \multirow[c]{14}{*}{Medium} & 40 & 43 & 76 & 6 & 1,160.5 & 6,055.8 & 0.0 & 49.1 & 3,286.4 & 990.0 & 173,509.5 & 5,990.6 & 0.0 & 33.9 & 25.4 & 3,061.3 & 788.6 & 147,510.1 \\
     & 42 & 47 & 104 & 8 & 1,565.0 & 8,107.1 & 12.0 & 53.3 & 3,637.1 & 119.4 & 1,372,936.3 & 8,301.9 & 12.0 & 54.3 & 16.8 & 3,200.5 & 140.1 & 1,361,393.1 \\
     & 63 & 70 & 94 & 7 & 1,746.5 & 13,783.0 & 0.0 & 238.7 & 983.2 & 1,554.6 & 313,077.0 & 13,673.5 & 0.0 & 195.9 & 59.7 & 1,025.2 & 1,407.3 & 268,524.2 \\
     & 67 & 78 & 116 & 8 & 1,839.5 & 13,456.8 & 0.0 & 132.7 & 1,869.0 & 614.3 & 214,501.3 & 13,484.8 & 0.0 & 98.0 & 22.7 & 1,792.8 & 622.4 & 177,710.8 \\
     & 71 & 82 & 116 & 8 & 2,060.0 & 11,393.8 & 9.0 & 265.1 & 2,714.8 & 1,054.6 & 1,279,068.9 & 10,793.3 & 9.0 & 242.0 & 41.8 & 3,197.9 & 665.2 & 1,262,000.5 \\
     & 57 & 70 & 117 & 6 & 2,327.5 & 14,975.0 & 0.0 & 324.1 & 1,005.5 & 1,149.6 & 392,281.0 & 15,303.5 & 0.0 & 295.2 & 54.6 & 659.4 & 1,083.8 & 351,940.4 \\
     & 79 & 83 & 137 & 7 & 2,425.0 & 17,644.3 & 0.0 & 553.8 & 2,320.4 & 1,993.3 & 680,888.1 & 17,379.3 & 0.0 & 474.0 & 55.7 & 2,964.4 & 2,016.3 & 620,601.6 \\
     & 66 & 80 & 127 & 8 & 2,512.5 & 14,584.3 & 0.0 & 128.3 & 1,600.0 & 1,451.5 & 219,949.8 & 14,499.2 & 0.0 & 127.5 & 47.3 & 1,390.2 & 1,212.8 & 207,962.2 \\
     & 68 & 74 & 128 & 7 & 2,595.0 & 18,450.6 & 3.7 & 566.6 & 1,317.5 & 2,706.2 & 1,048,712.1 & 18,261.4 & 0.0 & 473.4 & 56.0 & 1,764.7 & 2,525.6 & 595,143.5 \\
     & 85 & 97 & 136 & 8 & 2,673.0 & 16,831.6 & 0.0 & 379.9 & 2,702.4 & 2,368.0 & 525,199.5 & 17,241.3 & 0.0 & 323.7 & 50.2 & 2,190.5 & 2,767.1 & 461,973.3 \\
     & 78 & 85 & 128 & 8 & 2,685.5 & 15,679.8 & 63.0 & 474.5 & 1,399.6 & 2,394.4 & 6,880,077.6 & 15,830.6 & 63.0 & 432.7 & 57.8 & 1,206.8 & 2,272.7 & 6,830,154.3 \\
     & 77 & 85 & 131 & 8 & 2,893.5 & 16,988.0 & 0.0 & 374.5 & 1,557.9 & 1,996.1 & 478,106.8 & 16,565.6 & 0.0 & 352.1 & 44.6 & 1,624.3 & 1,322.5 & 443,865.0 \\
     & 89 & 97 & 137 & 7 & 2,939.5 & 21,716.4 & 9.8 & 924.4 & 821.0 & 3,494.4 & 2,020,622.6 & 21,311.3 & 0.0 & 799.5 & 51.8 & 887.3 & 3,486.7 & 917,162.4 \\
     & 84 & 98 & 133 & 7 & 2,971.0 & 20,435.5 & 46.1 & 1,141.3 & 894.1 & 2,127.8 & 5,841,090.1 & 20,520.4 & 9.0 & 1,411.0 & 59.5 & 705.0 & 1,871.9 & 2,390,157.6 \\
     \cmidrule(l){1-12} \cmidrule(l){13-19}
     \multicolumn{5}{r}{Average} & - & 15,007.3 & 10.2 & 400.4 & 1,864.9 & 1,715.3 & 1,531,430 & 14,939.8 & 6.6 & 379.5 & 46.0 & 1,833.6 & 1,584.5 & 1,145,436 \\
    \cmidrule(l){1-12} \cmidrule(l){13-19}
    \multirow[c]{14}{*}{Large} & 98 & 109 & 132 & 8 & 3,078.5 & 22,994.6 & 0.0 & 465.5 & 496.5 & 3,804.8 & 579,471.0 & 22,712.7 & 0.0 & 351.5 & 56.2 & 803.2 & 4,011.3 & 478,549.4 \\
     & 101 & 119 & 129 & 8 & 3,229.0 & 17,323.1 & 11.0 & 657.8 & 1,577.6 & 2,375.9 & 1,869,937.5 & 17,311.8 & 11.0 & 598.8 & 58.4 & 1,507.7 & 1,948.1 & 1,800,315.9 \\
     & 114 & 136 & 141 & 8 & 3,350.5 & 19,891.6 & 39.1 & 1,255.8 & 1,366.2 & 2,251.9 & 5,271,698.5 & 19,556.2 & 18.0 & 1,366.7 & 57.9 & 1,380.0 & 2,695.1 & 3,281,568.6 \\
     &  114& 132 & 140 & 8 & 3,401.5 & 21,917.6 & 23.8 & 1,254.1 & 680.1 & 3,389.9 & 3,744,172.5 & 22,590.2 & 17.5 & 1,248.5 & 58.7 & 766.3 & 3,267.6 & 3,109,441.2 \\
     & 101 & 123 & 143 & 8 & 3,437.5 & 23,477.2 & 0.0 & 677.7 & 955.5 & 4,369.4 & 817,244.5 & 23,806.9 & 0.0 & 617.3 & 56.0 & 1,302.2 & 5,147.9 & 783,123.1 \\
     & 112 & 129 & 137 & 8 & 3,471.0 & 22,089.2 & 0.0 & 546.6 & 544.8 & 4,187.3 & 668,737.0 & 21,195.2 & 0.0 & 456.6 & 55.0 & 883.9 & 3,532.1 & 574,935.0 \\
     & 114 & 129 & 142 & 8 & 3,499.5 & 20,678.2 & 35.7 & 1,007.5 & 1,119.7 & 4,133.1 & 4,714,436.9 & 21,243.7 & 21.0 & 907.0 & 59.8 & 1,038.0 & 4,016.6 & 3,139,750.0 \\
     & 98 & 122 & 149 & 8 & 3,513.0 & 19,859.0 & 28.4 & 1,141.7 & 2,154.6 & 2,649.9 & 4,119,224.3 & 19,602.8 & 21.0 & 859.2 & 55.7 & 2,342.9 & 2,728.2 & 3,103,676.6 \\
     & 98 & 108 & 139 & 8 & 3,541.0 & 21,060.5 & 0.0 & 966.2 & 684.9 & 3,585.4 & 1,079,477.1 & 21,084.8 & 0.0 & 867.2 & 59.8 & 834.9 & 4,133.9 & 996,046.7 \\
     & 108 & 122 & 144 & 8 & 3,670.5 & 23,330.4 & 2.0 & 1,123.4 & 536.2 & 3,251.6 & 1,427,866.8 & 22,882.8 & 0.0 & 969.7 & 57.8 & 649.7 & 3,587.1 & 1,083,850.9 \\
     & 92 & 107 & 142 & 8 & 3,684.5 & 23,179.0 & 0.0 & 578.3 & 384.1 & 4,260.4 & 698,184.4 & 23,610.6 & 0.0 & 449.2 & 59.8 & 315.7 & 4,257.2 & 567,403.7 \\
     & 114 & 136 & 138 & 8 & 3,739.5 & 23,614.6 & 11.7 & 1,225.1 & 837.4 & 5,668.6 & 2,557,166.5 & 22,859.0 & 7.5 & 1,107.0 & 58.3 & 1,224.2 & 5,078.2 & 2,018,119.1 \\
     & 127 & 136 & 150 & 8 & 3,946.5 & 24,940.3 & 0.0 & 949.5 & 775.5 & 5,384.3 & 1,105,391.3 & 24,939.2 & 0.0 & 829.0 & 57.1 & 805.9 & 6,166.7 & 1,001,490.6 \\
     & 112 & 131 & 148 & 8 & 3,953.5 & 24,286.0 & 34.0 & 1,247.8 & 657.0 & 3,009.5 & 4,752,026.9 & 24,221.7 & 24.5 & 1,118.5 & 57.1 & 859.7 & 3,483.3 & 3,688,169.1 \\
     \cmidrule(l){1-12} \cmidrule(l){13-19}
     \multicolumn{5}{r}{Average} &- & 22,045.8&        13.3& 935.5&      912.1&   3,737.3 & 2,386,074 & 21,972.7 & 8.6 & 839.0 & 57.7 & 1,051.0&3,860.9 & 1,830,460  \\
    \bottomrule
    \end{tabular}
    }
\end{table}

Table \ref{tab_cdp_runtime} shows that a higher percentage of deliveries are completed as the algorithm runtime increases. For small instances, all requests are delivered in less than a minute, while for medium and large instances, 99\% of requests are delivered. 

\begin{table}[htb]
    \centering
    \caption{RMC delivery completion within different runtimes of the GRASP}
    \label{tab_cdp_runtime}
    \scriptsize
    \resizebox*{0.7\textwidth}{!}{
    \begin{tabular}{llrrrrr}
    \toprule
     &  & \multicolumn{5}{c}{Runtime (min)} \\
     \cmidrule{3-7}
     &  & 1 & 5 & 10 & 30 & 60 \\
    \midrule
    Small & \%Load & 100.00 & 100.00 & 100.00 & 100.00 & 100.00 \\
    Medium & \%Load & 99.00 & 99.29 & 99.29 & 99.43 & 99.57 \\
    Large & \%Load & 99.00 & 99.21 & 99.36 & 99.43 & 99.50 \\
    \bottomrule
    \end{tabular}
    }
\end{table}

The medium instance $C\_42\_47\_104\_8$ has an unserved customer with a demand of 12 $m^3$ and a due time of $07\text{:}00$. Upon investigation, we find that even though we have $104$ drivers in this instance, the number of drivers who start their shift before $07\text{:}00$ is insufficient to serve this customer within the 60-minute window we defined. Thus, the value of $UQ$ that we report in Table~\ref{tab:cdp_all_instances} appears optimal given the driver shift schedule given as input to our algorithm. We confirmed this observation by removing the driver start shift and overtime constraints and resolving our instances five more times. All orders are now fully serviced on each run, as shown in Table~\ref{tab:cdp_all_instances_no_shift}. Table~\ref{tab:lift_shift_constraints} compares the averages of the results from Tables \ref{tab:cdp_all_instances} and \ref{tab:cdp_all_instances_no_shift}. We found that the maximum delay dropped to zero for small instances, and for medium (large) instances, it was reduced by almost 60\% (40\%) on average. This suggests that when we input a good work schedule, our algorithm works effectively to ensure that all orders are filled and that delays for first deliveries and travel costs are minimized. We can see that the average travel time decreases in all cases except the large one, where the difference is not significant.

\begin{table}[ht!]
    \centering
    \caption{Results with all instances without shift and overtime constraints}
    \label{tab:cdp_all_instances_no_shift}
    \resizebox{\textwidth}{!}{
    \begin{tabular}{lcccccccccccccc}
    \toprule
    &  &  &  &  & \multicolumn{4}{c}{Avg} & \multicolumn{5}{c}{Best}  \\
     \cmidrule(l){7-10} \cmidrule(l){11-15}
     &  &  &  &  & Demand & $TC$ & $UQ$ & $FDD$ & \multirow[c]{2}{*}{Z} & $TC$ & $UQ$ & $FDD$ & $mFDD$ & \multirow[c]{2}{*}{Z} \\
     & |$C$| & $|O|$ & $|K|$ & $|B|$ & (m$^3$) & (min) & (m$^3$) & (min) &  & (min) & (m$^3$)& (min) & (min) &  \\
    \midrule
    \multirow[c]{8}{*}{Small} & 11 & 12 & 13 & 1 & 226.5 & 1,243.5 & 0.0 & 0.0 & 1,243.5 & 1,243.5 & 0.0 & 0.0 & 0.0 & 1,243.5 \\
     & 5 & 8 & 13 & 1 & 267.0 & 745.1 & 0.0 & 0.0 & 745.1 & 745.1 & 0.0 & 0.0 & 0.0 & 745.1 \\
     & 6 & 11 & 18 & 2 & 333.5 & 753.3 & 0.0 & 0.0 & 753.3 & 753.3 & 0.0 & 0.0 & 0.0 & 753.3 \\
     & 4 & 7 & 15 & 2 & 375.0 & 1,013.7 & 0.0 & 0.0 & 1,013.7 & 1,013.1 & 0.0 & 0.0 & 0.0 & 1,013.1 \\
     & 7 & 8 & 19 & 2 & 388.0 & 1,661.0 & 0.0 & 0.0 & 1,661.0 & 1,658.2 & 0.0 & 0.0 & 0.0 & 1,658.2 \\
     & 10 & 14 & 29 & 3 & 613.5 & 3,235.5 & 0.0 & 0.0 & 3,235.5 & 3,198.6 & 0.0 & 0.0 & 0.0 & 3,198.6 \\
     & 8 & 11 & 31 & 3 & 776.0 & 2,257.6 & 0.0 & 0.0 & 2,257.6 & 2,219.9 & 0.0 & 0.0 & 0.0 & 2,219.9 \\
     & 9 & 10 & 35 & 3 & 937.5 & 3,834.0 & 0.0 & 0.0 & 3,834.0 & 3,808.8 & 0.0 & 0.0 & 0.0 & 3,808.8 \\
     \cmidrule(l){1-10} \cmidrule(l){11-15}
     \multicolumn{5}{r}{Average} & - & 1,843.0 & 0.0 & 0.0 & 1,843.0 & 1,830.1 & 0.0 & 0.0 & 0.0 & 1,830.1 \\
     \cmidrule(l){1-10} \cmidrule(l){11-15}
    \multirow[c]{14}{*}{Medium} & 40 & 43 & 76 & 6 & 1,160.5 & 5,262.4 & 0.0 & 0.0 & 5,262.4 & 5,187.2 & 0.0 & 0.0 & 0.0 & 5,187.2 \\
     & 42 & 47 & 104 & 8 & 1,565.0 & 8,278.0 & 0.0 & 0.0 & 8,278.0 & 8,209.6 & 0.0 & 0.0 & 0.0 & 8,209.6 \\
     & 63 & 70 & 94 & 7 & 1,746.5 & 12,730.3 & 0.0 & 0.0 & 12,730.3 & 12,551.9 & 0.0 & 0.0 & 0.0 & 12,551.9 \\
     & 67 & 78 & 116 & 8 & 1,839.5 & 11,884.4 & 0.0 & 0.0 & 11,884.4 & 11,641.4 & 0.0 & 0.0 & 0.0 & 11,641.4 \\
     & 71 & 82 & 116 & 8 & 2,060.0 & 10,750.9 & 0.0 & 0.0 & 10,750.9 & 10,697.1 & 0.0 & 0.0 & 0.0 & 10,697.1 \\
     & 57 & 70 & 117 & 6 & 2,327.5 & 14,547.0 & 0.0 & 25.8 & 40,380.4 & 14,746.8 & 0.0 & 16.1 & 9.1 & 30,816.0 \\
     & 79 & 83 & 137 & 7 & 2,425.0 & 17,822.4 & 0.0 & 120.0 & 137,840.9 & 17,982.5 & 0.0 & 92.0 & 17.6 & 110,023.4 \\
     & 66 & 80 & 127 & 8 & 2,512.5 & 13,622.2 & 0.0 & 0.0 & 13,622.2 & 13,565.0 & 0.0 & 0.0 & 0.0 & 13,565.0 \\
     & 68 & 74 & 128 & 7 & 2,595.0 & 18,641.7 & 0.0 & 74.1 & 92,744.7 & 18,554.8 & 0.0 & 43.4 & 19.0 & 61,987.5 \\
     & 85 & 97 & 136 & 8 & 2,673.0 & 17,336.3 & 0.0 & 51.8 & 69,145.9 & 17,610.5 & 0.0 & 23.1 & 16.3 & 40,731.6 \\
     & 78 & 85 & 128 & 8 & 2,685.5 & 16,781.2 & 0.0 & 55.5 & 72,294.4 & 16,658.5 & 0.0 & 39.4 & 12.5 & 56,076.4 \\
     & 77 & 85 & 131 & 8 & 2,893.5 & 17,789.1 & 0.0 & 22.0 & 39,787.5 & 16,923.5 & 0.0 & 0.0 & 0.0 & 16,923.5 \\
     & 89 & 97 & 137 & 7 & 2,939.5 & 21,831.7 & 0.0 & 214.2 & 236,037.5 & 22,630.7 & 0.0 & 157.1 & 48.5 & 179,691.7 \\
     & 84 & 98 & 133 & 7 & 2,971.0 & 21,031.1 & 0.0 & 474.0 & 495,073.6 & 21,179.3 & 0.0 & 359.8 & 59.8 & 380,980.3 \\
     \cmidrule(l){1-10} \cmidrule(l){11-15}
     \multicolumn{5}{r}{Average}  & - & 14,879.2 & 0.0 & 74.1 & 88,988.1 & 14,867.1 & 0.0 & 52.2 & 13.1 & 67,077.3 \\
     \cmidrule(l){1-10} \cmidrule(l){11-15}
     \multirow[c]{14}{*}{Large} & 98 & 109 & 132 & 8 & 3,078.5 & 22,272.3 & 0.0 & 7.2 & 29,438.3 & 23,294.5 & 0.0 & 4.0 & 1.8 & 27,252.8 \\
     & 101 & 119 & 129 & 8 & 3,229.0 & 18,473.8 & 0.0 & 41.6 & 60,111.3 & 18,595.2 & 0.0 & 28.0 & 15.7 & 46,551.2 \\
     & 114 & 136 & 141 & 8 & 3,350.5 & 21,237.4 & 0.0 & 136.7 & 157,923.2 & 20,762.9 & 0.0 & 110.7 & 18.6 & 131,504.9 \\
     & 114 & 132 & 140 & 8 & 3,401.5 & 22,518.4 & 0.0 & 174.0 & 196,489.2 & 22,537.0 & 0.0 & 64.8 & 10.6 & 87,390.4 \\
     & 101 & 123 & 143 & 8 & 3,437.5 & 23,807.5 & 0.0 & 39.1 & 62,917.8 & 23,249.3 & 0.0 & 30.2 & 13.8 & 53,413.3 \\
     & 112 & 129 & 137 & 8 & 3,471.0 & 22,457.5 & 0.0 & 121.0 & 143,439.3 & 21,878.2 & 0.0 & 27.9 & 7.5 & 49,772.5 \\
     & 114 & 129 & 142 & 8 & 3,499.5 & 21,574.4 & 0.0 & 362.8 & 384,413.2 & 22,591.1 & 0.0 & 221.0 & 52.9 & 243,564.1 \\
     & 98 & 122 & 149 & 8 & 3,513.0 & 20,918.7 & 0.0 & 150.6 & 171,499.5 & 19,503.4 & 0.0 & 94.1 & 28.6 & 113,643.5 \\
     & 98 & 108 & 139 & 8 & 3,541.0 & 21,548.1 & 0.0 & 271.5 & 293,062.8 & 22,008.3 & 0.0 & 239.9 & 47.4 & 261,921.3 \\
     & 108 & 122 & 144 & 8 & 3,670.5 & 23,604.0 & 0.0 & 169.2 & 192,821.5 & 23,200.9 & 0.0 & 125.9 & 42.5 & 149,122.9 \\
     & 92 & 107 & 142 & 8 & 3,684.5 & 21,279.5 & 0.0 & 83.8 & 105,084.6 & 21,244.2 & 0.0 & 36.4 & 14.4 & 57,641.8 \\
     & 114 & 136 & 138 & 8 & 3,739.5 & 24,385.3 & 0.0 & 109.8 & 134,180.9 & 25,218.0 & 0.0 & 71.7 & 15.8 & 96,877.5 \\
     & 127 & 136 & 150 & 8 & 3,946.5 & 24,434.2 & 0.0 & 391.0 & 415,476.7 & 24,732.2 & 0.0 & 292.5 & 52.8 & 317,191.2 \\
     & 112 & 131 & 148 & 8 & 3,953.5 & 25,846.2 & 0.0 & 566.8 & 592,677.4 & 26,245.8 & 0.0 & 383.8 & 52.7 & 410,087.8 \\
     \cmidrule(l){1-10} \cmidrule(l){11-15}
     \multicolumn{5}{r}{Average} & - & 22,454.1 & 0.0 & 187.5 & 209,966.8 & 22,504.4 & 0.0 & 123.6 & 26.8 & 146,138.2 \\
    \bottomrule
    \end{tabular}
    }
\end{table}

\begin{table}[!ht]
    \centering
    \small
    \caption{Comparison of the average results with and without shift and overtime constraints}
    \label{tab:lift_shift_constraints}
    \resizebox{0.8\textwidth}{!}{
    \begin{tabular}{lcccccccc}
    \toprule
     & \multicolumn{4}{c}{Default parameters}&\multicolumn{4}{c}{$\mu=0$, $\eta,\varLambda=\infty$, $h_k=0$} \\
     \cmidrule(l){2-5} \cmidrule(l){6-9}
     & $TC$ & $UQ$ & $FDD$ & $mFDD$ & $TC$ & $UQ$ & $FDD$ & $mFDD$ \\
     & (min) & ($m^3$) & (min) & (min) & (min) & ($m^3$) & (min) & (min) \\
    \midrule
    Small & 1,938.13 & 0.00 & 7.44 & 4.47 & 1,842.97 & 0.00 & 0.00 & 0.00 \\
    Medium & 15,007.28 & 10.26 & 400.45 & 46.31 & 14,879.19 & 0.00 & 74.11 & 17.87 \\
    Large & 22,045.81 & 13.26 & 935.49 & 56.93 & 22,454.09 & 0.00 & 187.51 & 34.76 \\
    \bottomrule
    \end{tabular}
    }
\end{table}

\subsection{Sensitivity analyses}

In this section, we analyze the effect on the solution when we change some parameters of our problem and how some objective function components influence each other.

\subsubsection{Influence of the maximum time delay $\gamma^1$}

We ran additional tests with different values of $\gamma^1$, varying between 5 and 25 minutes, with no shifts or overtime constraints on the drivers. The influence of the value of the maximum time delay between two consecutive deliveries of the same order is shown in Figure~\ref{fig:gamma1_influence}. For small instances, all customers are served on time regardless of the value of $\gamma^1$. For medium (large) instances, all customers are served with $\gamma^1$ starting at 15 (20) minutes. The delay of initial delivery decreases as $\gamma^1$ increases. These results confirm the fact that when $\gamma^1$ is high, plants have more flexibility to delay current deliveries to make room for new ones or to make customers wait until drivers are available. Increasing the maximum delay from 10 to 20 minutes reduces the first delivery delay by over 50\% for the medium and large cases. The average delivery time does not change significantly regardless of the value of $\gamma^1$.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=1\textwidth]{gamma1.pdf}
    \small
    \caption{Influence of the maximum time delay ($\gamma^1$) between consecutive deliveries of the same order. }
    \label{fig:gamma1_influence}
\end{figure}

\subsubsection{Trade-off of the objective function components}

We ran five tests on our dataset and obtained two solutions per instance: one that minimizes the travel time and another that minimizes the first delivery delay. Table~\ref{tab:cdp_tradeoff} reports the trade-off between the travel time and the first delivery delay for these solutions. The difference is not notable for small instances. However, for medium and large instances, it is clear that as the first delivery delay decreases, the travel time increases, and conversely, when we minimize the travel time, the first delivery delay tends to be longer. This result is expected because drivers assigned to one plant often must travel to another to ensure that the first delivery remains on schedule. This trade-off highlights the challenge decision-makers face in finding the right balance between minimizing operational costs and meeting customer satisfaction.

\begin{table}[!ht]
    \centering
    \caption{Trade-off between travel cost and first delivery delay}
    \label{tab:cdp_tradeoff}
    \begin{adjustbox}{max width=0.8\textwidth}
    \begin{tabular}{lcccccc}
    \toprule
     & \multicolumn{3}{c}{Minimize TC} & \multicolumn{3}{c}{Minimize $FDD$} \\
     \cmidrule(l){2-4} \cmidrule(l){5-7}
     & $TC$ & $FDD$ & $mFDD$ & $TC$ & $FDD$ & $mFDD$ \\
     & (min) & (min) & (min) & (min) & (min) & (min) \\
    \midrule
    Small & 1,837.8 & 0.0 & 0.0 & 1,841.9 & 0.0 & 0.0 \\
    Medium & 14,390.1 & 60.6 & 17.2 & 14,687.1 & 46.5 & 16.4 \\
    Large & 21,753.1 & 180.0 & 33.7 & 22,316.4 & 128.1 & 37.7 \\
    \bottomrule
    \end{tabular}
\end{adjustbox}
    
\end{table}

\section{Conclusion}
\label{sec:cdp_concl}

In this paper, we investigated a variant of the concrete delivery problem, where customers can order different types of concrete from different production centers, which must be delivered during the same time window. To solve this problem, we introduced a mathematical model and a heuristic solution based on Greedy Randomized Adaptive Search. Our analysis, using a dataset derived from our partner's historical data, demonstrated the effectiveness of our algorithm in making good decisions within a reasonable time. Furthermore, our model incorporates constraints related to working hours, making our heuristic a valuable tool for designing weekly schedules for company drivers. It can also better reassign drivers to their home plants, as these assignments affect travel costs to ensure timely deliveries. Our GRASP algorithm performed exceptionally well on \cite{kinable2014concrete} datasets, indicating its reliability. For future work, it would be interesting to address datasets with different unloading times at construction sites or to explore different scenarios regarding the number of simultaneous deliveries and the maximum time between two consecutive deliveries at a construction site. We can also study the problem using a stochastic or robust methodology to account for the uncertainty of the parameters in a real-world setting. As a contribution to the literature on CDP, we provide a mathematical formulation for our variant, contribute a dataset, and demonstrate the application of GRASP to solve both our problem and the one studied by \cite{kinable2014concrete}.


\vspace{1.5cm} \noindent \textbf{Acknowledgments}

Financial support for this work was provided by the Canadian Natural Sciences and Engineering Research Council (NSERC) under grants 2019-00094 and 2021-04037. This support is gratefully acknowledged. We thank the Digital Research Alliance of Canada for providing high-performance computing facilities.

\bibliographystyle{plainnat}
\bibliography{references} 

\end{document}
\documentclass{article}
% \documentclass[review]{elsarticle}
\usepackage{epsfig}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage[algo2e,noend]{algorithm2e}
\usepackage[compatible,noend]{algpseudocode}
\usepackage{enumitem}
\usepackage{xspace}
\usepackage[table,xcdraw]{xcolor}
\usepackage{amsfonts}
\usepackage{pifont}
\usepackage{bbding}
\usepackage[english]{babel}
\usepackage{adjustbox}
\usepackage{tikz}
\usetikzlibrary{automata, topaths, calc, positioning, shapes, backgrounds, fit, matrix}
\usepackage{caption}
\usepackage{tabularx}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{datatool}
\usepackage{array}
\usepackage{pgfplotstable}
\pgfplotsset{width=7cm,compat=newest}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{pdflscape}
\usepackage{afterpage}
\usepackage{capt-of}
\usepackage{multirow}
\usepackage{float}
\usepackage[text={15cm,21cm},centering]{geometry}
\usepackage{setspace}
\usepackage{array}
\allowdisplaybreaks
\usepackage{lineno}
\usepackage{tkz-graph}
\usepackage{breqn}
\tikzset{
base/.style = {shape=rectangle, 
                      anchor=center,minimum size=5mm, 
                     align=center,
                     top color=white, ,inner sep=0ex,
                     minimum size=5mm
                     },
    LC11/.style =   {  base,   
                    text width=3em, 
                    bottom color=brown!100,
                    },
    UC11/.style = {     base,    
                    text width=5em, 
                    bottom color=brown!100,
                    align = right,
                },
    LC12/.style =   {  base,   
                    text width=1em, 
                    bottom color=orange!100,
                    },
    UC12/.style = {     base,    
                    text width=2.5em, 
                    bottom color=orange!100,
                },
    LC21/.style =   {  base,   
                    text width=1.5em, 
                    bottom color=brown!100,
                    },
    UC21/.style = {     base,    
                    text width=3.5em, 
                    bottom color=brown!100,
                },
    LC22/.style =   {  base,   
                    text width=4em, 
                    bottom color=blue!100,
                    },
    UC22/.style = {     base,    
                    text width=7em, 
                    bottom color=blue!100,
                    align = left,
                },
    UC221/.style = {     base,    
                    text width=3.5em, 
                    bottom color=blue!100,
                    % color=blue!100,
                    outer xsep=0em,
                    % align = right,
                },
                UC231/.style =   {  base,   
                    text width=1.5em, 
                    bottom color=blue!100,
                    },
    LC23/.style =   {  base,   
                    text width=1.5em, 
                    bottom color=orange!100,
                    },
    UC23/.style = {     base,    
                    text width=2.em, 
                    bottom color=orange!100,
                },
  env/.style      = {base, font=\ttfamily\normalsize},
label/.style   = {base,font=\ttfamily\normalsize, text width = 8em, 
  inner sep=0em, rounded corners=1mm,bottom color=red!80,},
  dummy/.style    = {circle,draw}
}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newcommand{\pcmaxc}{P$|\mbox{\em cont}|$C$_{\max}$\xspace}

\newcommand{\GRASP}{Greedy randomized adaptive search procedure\xspace}
\newcommand{\F}{$\mathcal{F}$\xspace}
\newcommand{\B}{$\mathcal{B}$\xspace}
\newcommand{\C}{$\mathcal{C}$\xspace}
\newcommand{\LB}{$\mathcal{L}$\xspace}
\newcommand{\Lb}{$\mathcal{L}_b$\xspace}
\newcommand{\D}{$\mathcal{D}$\xspace}
 \newcommand*{\red}{\textcolor{red}}

\renewcommand{\algorithmicforall}{\textbf{for each}}
\SetKwFor{ForEach}{for each}{}{}%
\renewcommand{\algorithmiccomment}[2][1\linewidth]{%
\leavevmode\hfill\makebox[#1][l]{/* \textbf{~#2} */}}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}

\renewcommand{\tabcolsep}{4pt}

\modulolinenumbers[1]
\linenumbers

\oddsidemargin=0.5in
\topmargin=-0.25in
\textwidth=5.5in
\textheight=8.25in

%\journal{European Journal of Operational Research}

%\begin{frontmatter}

		
\title{A GRASP algorithm for the concrete delivery problem. }
\author{Ousmane Ali$^{(1)}$, Jean-Fran\c cois C\^ot\'e$^{(2)}$, Leandro C.~Coelho$^{(3)}$\\
 $(1)$ {\tt nassoma-wattara-ousmane.ali.1@ulaval.ca}\\
 $(2)$ {\tt Jean-Francois.Cote@fsa.ulaval.ca}\\
 $(3)$ {\tt Leandro.Coelho@fsa.ulaval.ca}\\
}

% \date{\today}

\begin{document}
\maketitle
\begin{abstract}
    The concrete delivery problem (CDP) is a combinatorial optimization problem that involves scheduling the delivery of ready-mixed concrete to construction sites while balancing the conflicting goals of minimizing transportation costs and maximizing customer satisfaction. This paper proposes an exact formulation and a heuristic approach based on the Greedy Randomized Adaptive Search Procedure (GRASP) to tackle a new variant of the CDP that incorporates realistic side constraints, such as drivers' working shifts, minimum working time for each driver, and overtime penalties. Additionally, the problem also considers the possibility of customers requiring multiple types of concrete to be delivered within the same time window. The performance of the proposed heuristic is evaluated on real-world instances, and it is compared to another variant to demonstrate its effectiveness.

\end{abstract}

% \begin{keywords}
\noindent{\textbf{Keywords:} Vehicle scheduling;  concrete delivery; GRASP; ready-mixed concrete }
% \end{keywords}

%\end{frontmatter}

\section{Introduction}
\label{sec:intro}
Concrete is a widely used building material in construction projects. Its perishable nature is affected by many factors that impact its quality \citep{sinha_quality_2021}, which is crucial for the durability and strength of the final construction. Concrete comes in two types: ready-mixed concrete (RMC) and site-mixed concrete (SMC). RMC is manufactured in a batch plant and delivered to the construction site, while SMC is produced on-site using raw materials stored on the construction site. Using SMC can avoid delays caused by road traffic, but it has a slower and more difficult production process, requires storage for mixing materials and equipment, and is suitable for low amounts of concrete. On the other hand, RMC has better quality and benefits from lower production costs \citep{muresan_comparing}. However, to take advantage of these benefits, the batch plant manager must ensure efficient and prompt delivery on the construction site, which may require a fleet of high-cost revolving drum trucks (concrete mixers) to dispatch the RMC.

Concrete delivery under the form of RMC is subject to many operational constraints that make the Concrete Delivery Problem (CDP) very challenging. In this paper, we study a variant of the CDP to schedule the daily production and dispatching of RMC for a company located in the province of Quebec, Canada. This company operates multiple batch plants with varying production rates, using a fleet of concrete mixers of different capacities. Each plant has its own fleet of trucks; however, under certain conditions, the trucks can move between plants if necessary. The trucks must return to their home plant at the end of the day. The company owns two types of trucks with different capacities and can call on an external fleet when needed. They serve construction sites from any of their plants, with the first delivery starting at the time specified by the customer. The loading and unloading of a concrete mixer depend on the truck capacity, the loading rate at the plant, and the unloading rate at the construction site. Drivers are allocated based on their daily work schedules. A customer may request several types of concrete to be delivered within the same time window, with no required sequence for the orders, but an order can only start after the completion of the previous order. This constraint generalizes the linked order constraints of \cite{durbin2008or} where some customers place two orders for the same day and request that they are linked (the second order begins only after the first order is completed). The setting of our study is similar to a variant of the CDP previously studied in \cite{schmid2009hybrid, schmid2010hybridization}. However, we include the plant's production rate and driver shift schedule. The company uses a centralized dispatcher system to schedule all daily orders, but this system has issues satisfying all daily demands without using an external fleet.
% Also, as per union rules, they assign a truck driver to a delivery task based on his seniority.

According to \cite{blazewicz2019handbook}, the CDP combines vehicle routing with scheduling issues to plan routes to deliver concrete from batch plants (depots) to customers' construction sites. RMC is an on-demand product with a short life cycle from production through end use. It cannot be stored and cannot stay too long on a truck, or it will harden. Hence, concrete mixers must deliver RMC at the planned construction site shortly after its production. \cite{tommelein1999just} describes RMC production and delivery as an example of a just-in-time (JIT) production system in construction. A customer quantity requirement is often greater than the truck size and must be fulfilled by multiple deliveries. In that sense, CDP is similar to the vehicle routing problem with split delivery \citep{archetti2008split}, except that the same truck may visit a customer more than once. Concrete hardens quickly, so multiple deliveries must be done back-to-back or at least close in time to avoid the problem of cold joint, which can reduce the strength and durability of the concrete. Customers request to be served within a specific time window, which can complicate truck-loading schedules when a plant can only load one truck at a time. Similarly, only one truck can unload at a time at a customer location, sometimes leading to concrete mixers queuing and waiting their turn to deliver. Furthermore, with trucks of varied sizes, loading, travel, and unloading times that may be uncertain, the CDP is a complex and challenging problem.

In this paper, we propose a mathematical model and a Greedy Randomized Search Procedure (GRASP) heuristic to solve a new variant of the CDP. Our model takes into consideration the working shifts of the drivers and the scheduling of multiple orders within the same time window at a construction site. To the best of our knowledge, this paper is the first that deals with these specific constraints in the context of the CDP.

The rest of the paper is structured as follows: Section \ref{lit_review} provides a literature review of previous work related to the CDP. Section \ref{desc_form} provides a formal description and mathematical model of the problem. In Section \ref{grasp_method}, we describe the GRASP algorithm and the constructive heuristics developed to solve this variant of the CDP. Section \ref{comp_exp} presents computational experiments to evaluate the proposed approach, and finally, the conclusions are presented in Section \ref{concl}.

\section{Literature review}
\label{lit_review}

Academic Research on concrete batch and delivery began in the late 1990s. \cite{tommelein1999just} described RMC as a prototypical example of a JIT production system in construction and identified two practices for delivering it. One approach is for the customer to haul the product from the batch plant with their concrete mixer, while the other is for the batch plant to deliver the concrete directly to the customer's location. This latter approach is the one that has been studied in all related papers found in the literature. Several works to schedule and dispatch concrete production and delivery have mainly focused on simulation-related methods. These methods can be standalone, such as those used by \cite{zayed2001simulation, wang2001scheduling, tian_simulation_based_2010, panas_simulation_based_2013} and \cite{galic2016simulation}, among others. Alternatively, these methods can be hybridized with optimization techniques, such as those used by \cite{feng2004optimizing, lu2005optimized}, and \cite{feng_integrating_2006}. \cite{wang2001scheduling} developed a simulation model to reveal the effect and value of the concrete mixers' inter-arrival time on the productivity of hired unloading equipment on site. \cite{feng2004optimizing} used a combination of genetic algorithm (GA) and simulation process to minimize the total waiting time for trucks at a customer site. The study focused on loading trucks with identical capacities at the same batch plant, with fixed loading and unloading durations. The GA was used to find the best loading sequence of RMC trucks to be assigned to different construction sites. The simulation process determined the loading, arrival, departure, and waiting time of trucks and thus evaluated the cost of each dispatching sequence. They evaluated their method using data from a batch plant in Taiwan with up to nine customers served. \cite{mayteekrieangkrai2015optimized} addressed the same problem with the same data using a bee algorithm (BA) and found better solutions than the GA. \cite{lu2005optimized} used the same combination of GA and simulation to determine the optimal number of concrete mixers to be deployed and an optimal schedule for batch and delivering concrete. Their objective was to minimize the idle time of the site crew due to late concrete deliveries and truck queuing time. In this setting, it was also necessary to deliver a batch of mortar on-site to lubricate the unloading pump before the concrete delivery. As such, the simulation model also included the batch and delivery of mortar. Finding the best RMC fleet size was also the purpose of the discrete-event simulation model proposed by \cite{panas_simulation_based_2013}.

In addition to simulation-based methods, several other approaches have been used in the literature to solve the CDP. These include metaheuristics \citep{faria2006distributed, misir2011selection, maghrebi2016sequential, yang2022concrete}, exact methods \citep{yan2007optimal, asbach2009analysis, kinable2014concrete}, matheuristics \citep{schmid2009hybrid, schmid2010hybridization}, Benders Decomposition \citep{maghrebi2014benders}, column generation (CG) \citep{maghrebi2014solving, maghrebi2016column}, Lagrangian relaxation \citep{narayanan2015using}, and machine learning approaches such as those used by \cite{graham2006modeling, maghrebi2014exploring, maghrebi2016matching}. \cite{matsatsinis2004towards} designed a decision support system (DSS) for the dynamic routing of both concrete and pumps that may be necessary for some construction sites to aid in the unloading of concrete. The DSS considered the availability of three plants but stipulated that vehicles fulfilling the same order must all load at the same plant. Orders that could not be executed immediately could be postponed for the next day. The routing of the pumps was modeled as a multi-depot vehicle routing problem with time windows. \cite{naso2007genetic} proposed a sequential GA method combined with constructive heuristics to solve another variant of the CDP. In this problem, the plant's production schedule must account for orders for concrete to be delivered to a customer site and orders that customers must pick up themselves. The algorithm first schedules the plant loading operations before scheduling truck deliveries. The authors also developed a non-linear model that minimizes transportation costs, waiting times, outsourced costs, and overtime work. They ran experiments using real-world instances of a concrete supply chain in the Netherlands and found a reduction in the number of outsourced requests. \cite{yan2007optimal} also considered overtime considerations in their paper, which focused on scheduling RMC for one batch plant with two loading docks. The study took into account that overtime wages are paid for factory and construction site operations after 4 PM. They developed a mixed-integer programming (MIP) model on a time-space network to minimize travel times and operating costs at both normal and overtime working hours at the plant and the construction sites. They tested the model using real data consisting of three days of operation using a two-stage algorithm. First, they solved the MIP relaxation with CPLEX. Then, they simplified the original model by fixing some decision variables before solving it. The algorithm was found to improve the actual plant operation by 10\%. A time-space network is the key component of the real-time DSS developed by \cite{durbin2008or} to solve a dynamic CDP every five minutes. The DSS is able to receive new orders, schedule them on the fly, and handle unexpected events such as plant closures, truck breakdowns, and delays in transportation times. The authors combined the DSS with a tabu search (TS) heuristic to warm start CPLEX, which made the model performant enough to solve instances with up to 1,500 loads per day with up to 250 trucks. The DSS also considers the case of a customer who places two orders, with the first being completed before the second starts. Further insights on the real-time planning and monitoring of CDP are available in \cite{garza2021dynamic}. Another variant of the CDP is modeled by \cite{schmid2009hybrid} as an integer multicommodity network flow (MCNF) problem on a time-space network. In this paper, concrete is delivered using a heterogeneous fleet of vehicles, and each plant can load an unlimited number of trucks simultaneously. Some of the trucks have specialized equipment and must arrive first at certain construction sites to assist in unloading the concrete. The objective is to fulfill all orders, minimize the travel cost, and avoid delays between two consecutive unloading operations for an order. The model is typically solved using a matheuristic algorithm that combines the MCNF with a variable neighborhood search (VNS) heuristic. The method can quickly solve large problem instances with more than 60 orders per day without encountering any memory issues. The same problem is addressed by \cite{schmid2010hybridization}, who proposed a MIP model combined with a VNS and a very large neighborhood search (VLNS) to develop two matheuristics approaches. Comparisons between both matheuristics and a standalone VNS show that the former methods are much better and suitable for solving larger problem instances. These methods also provide better solutions for small to medium instances than the matheuristic used in \cite{schmid2009hybrid}. A pure VNS approach with the same problem but without the use of instrumentation has been applied by \cite{payr2009optimizing}.

Regarding objectives, most authors have focused on minimizing travel time and delays between consecutive deliveries. However, some authors have been more interested in maximizing customer satisfaction alone. We find these situations in the works of \cite{durbin2008or, kinable2014concrete, kinable2014logic, sulaman2017simulated}. \cite{kinable2014concrete} introduce a general MIP and constraint programming (CP) models of the CDP reflecting the main constraints commonly found in all CDP works: time lag and no overlapping between consecutive deliveries, covering of all customers' demands, delivery time window, and heterogeneous fleet. However, the model did not include constraints limiting the time that concrete may reside in a truck. The authors propose a constructive heuristic that schedules the visits to the customers one by one according to the start time of the visit and the truck capacity. The procedure is invoked multiple times for different permutations of the customer's order which is determined using the steepest descent (SD) local search procedure. One of the paper's main contributions is the creation of the first public test instances for the CDP with up to 50 customers, four batch plants, and 20 concrete mixers. They found the CP model to be highly effective in finding high-quality solutions in a relatively short time or improving existing schedules, while the MIP model can be used to compute bounds, as it seems ineffective in solving large problem instances. Finally, the heuristic often yields good solutions in less than a second. A detailed analysis of the MIP model presented in \cite{kinable2014concrete} and of two more compact models can be found in the thesis of \cite{hernandez_lopez_study_2020}. In \cite{kinable2014logic}, we found an attempt to solve the previous problem with a logic-based Benders' approach. %\cite{sulaman2017simulated} expand upon the SD-heuristic proposed in \cite{kinable2014concrete}, proposing a simulated annealing (SA) combined with a time-slot Heuristic (SATH). This method looks for a slot between existing visits of a truck to schedule a new delivery instead of assigning it to the time slot strictly after the truck's latest assigned delivery. The goal is to reduce the large time gaps that can be present in a schedule created with SD due to ignoring the intermediate available time slots. Experimental results indicated that SATH outperforms SD in speed and solution quality. 
A generalization of the MIP model of \cite{kinable2014concrete} is addressed in \cite{asbach2009analysis}. This model simultaneously minimizes the total sum of travel costs and the penalty costs for customers with unfulfilled demand. A customer can request that all concrete deliveries come from the same plant or a subset of plants and that a delivery truck belongs to a subset of the vehicle fleet. The MIP model is used in a local search scheme as a black-box solver to reoptimize an incumbent solution in which a neighborhood operator has unfixed some variables. \cite{tzanetos2023systematic} provide an overview of the various methods used in the literature to address the CDP and categorizes the problem formulations based on the different concepts used in the literature. They also discussed the consistency between industry needs and existing constraints and provided insights into the datasets corresponding to real-world cases, identifying the necessary data for practitioners.

\section{Problem description}
\label{desc_form}
The focus of this paper is on the distribution of RMC from a Canadian company that operates in the greater Montreal area. When a customer places an order, it is received at a control center and immediately assigned to one of the company's batch plants. These plants produce the concrete and then deliver it to the customer. The problem we are examining involves a set of customer orders, a set of concrete-mixer drivers, and a set of batch plants.

% \subsection*{Customer orders}

A customer $i$ requests one or more types of concrete to be delivered to their construction site on a specific day, with the delivery service starting at the due time $a_i$.  We call an order $o$ a request for a specific type of concrete. $q_i$ is the sum of the demands $q_o$ of each order $o$ placed, $a_i$ is the desired arrival time of the first concrete mixer, and $\tau^u_i$ is the unloading rate for customer $i$. If the order requires more concrete than a single truck can carry, multiple deliveries are scheduled.

Let $O_i$ be the set of all orders requested by customer $i$. Each element of $O_i$ must be fully delivered before moving on to another order. Exactly one order $o \in O_i$ must have its first delivery start at $a_i$, while the others can start at most $\gamma^2$ time after $o$ is completed. A plant is assigned to an order, and it must be the supplier of all subsequent deliveries of that order. 
To avoid cold joint problems with the concrete, subsequent deliveries of the same order must be made in close succession. We define a maximum time delay $\gamma^1$ after which no more deliveries are allowed. The customer's unloading rate and the quantity to be unloaded give the time required to unload a truckload. Let $\mathcal{C}$ be the set of construction sites (customers) with a planned delivery for the day, and $\mathcal{O}=\{{O_i, i \in \mathcal{C}}\}$ be the set of all requested orders for all customers.

% \subsection*{Drivers}

The company has two types of concrete mixer trucks with capacities of 8 and 12 cubic meters. Each driver $k$ is assigned to a particular batch plant and is responsible for driving a truck with capacity $Q_k$. The set of drivers is represented by $K =\cup_{b \in \mathcal{B}}K_b $, where $K_b$ is the set of drivers scheduled to start their shift at batch plant $b$. $t_{ij}$ is the known time to travel between any two locations $i$ and $j$. A scheduled driver $k$ is required to start his shift at $H_k$, work a minimum of $M_T$ hours and a maximum of $N_T$ hours during regular working hours, with the possibility of overtime of up to $O_T$ hours. $\beta_3$ and $\beta_4$ are the penalties for a driver working less than $M_T$ and more than $N_T$.

A driver typically loads RMC at his assigned batch plant but may be required to drive to and load at other plants if needed. The batch plant produces concrete on demand using recipes specific to each order. This means that a truck can only haul RMC for one order, even if there is spare capacity.  After unloading the RMC,  driver $k$ takes $\rho$ minutes to clean the concrete mixer before proceeding. %When assigning drivers to deliveries, the company prioritizes employees with the highest seniority.

Let $n_o$ be the number of deliveries needed to fulfill the order $o$. $n_o$ is not known in advance because we use a fleet of trucks with different capacities. However, we can compute its lower ($n_o^{min}$) and upper ($n_o^{max}$) bounds using the capacities of the largest ($Q_{max}$) and smallest ($Q_{min}$) available trucks.
\begin{alignat}{3}
    \label{mod:c0}
    n_o^{min} = \left\lceil \frac{q_o}{Q_{max}} \right\rceil \leq n_o \leq n_o^{max} = \left\lceil \frac{q_o}{Q_{min}} \right\rceil & \text{ } &
    \forall  o \in \mathcal{O}.
\end{alignat}

Let $d^j_{o}$ be the $j^{th}$ visit with load $q^j_{o}$ for order $o$. We represent the fulfillment of order $o$ by the visits to the ordered set of delivery nodes $\mathcal{D}_o= \left(d^0_{o},d^1_{o},\cdots, d^{n_o}_{o}\right)$. The deliveries of customer $i$ are the ordered set $\mathcal{D}_i= (\mathcal{D}_{o_1}, \mathcal{D}_{o_2},\cdots,\mathcal{D}_{o_{|O_i|}})$, where $o_r$ is the $r^{th}$ delivered order. We will refer to $d \in \mathcal{D}_i$ ($d \in \mathcal{D}_o$) as the $d^{th}$ potential delivery of customer $i$ (order $o$). $\mathcal{D}=\bigcup_{i\in \mathcal{C}} \mathcal{D}_i$ is the union of all delivery nodes.

% \subsection*{Batching plants}

Each of the company's plants has a single loading dock that can accommodate only one truck at a time. As a result, trucks often form a queue while waiting for their turn at the loading dock. Let $\mathcal{B}$ be the set of batch plants. The plants are heterogeneous, as each plant $b$ has its own hourly loading rate, represented by $\tau^l_b$, which affects the duration of the loading process. After loading the concrete, the driver spends $\alpha_b$ minutes adjusting the concrete in the truck before heading to the customer site. Each plant has its own assigned fleet of trucks, but it can borrow trucks from other plants. Let $l_{j}$ be the loading dock node associated with delivery node $j$. After loading RMC at $l_j$, it must be fully delivered to $j$ at most before $\Delta$ time, which is the concrete lifetime. We denote $\mathcal{L}_b$ as the set of loading dock nodes of plant $b$ and $\mathcal{L}$ as the set of all loading docks.

% \subsection*{Model}
A solution to the problem involves decisions about truck loading schedules, driver assignments to different deliveries, and truck arrival times at construction sites for unloading. For a batch plant, the decision involves choosing which driver to load, when to load them, how much to load, and which construction site to deliver. For a driver, the decision is to determine the sequence of loading depots and delivery sites. And for a construction site, the decision involves determining the arrival times of all scheduled deliveries for the day.

Each driver leaves and returns to their home plant every day. We represent the home plant of a driver $k$ with a starting depot $s_k$ and an ending depot $e_k$. $S$ and $E$ are the sets of starting and ending depots, respectively.

We define our problem on a complete directed graph where $V=\{ S \cup \mathcal{L} \cup \mathcal{D} \cup E\}$ is the set of nodes. The arc sets are $A =  \{(i,j,k) \hspace*{1mm} \vert \hspace*{1mm} i, j \in V \hspace{1mm} k\in K \}$, $A^D = \{(i,j) \hspace*{1mm} \vert \hspace*{1mm} i, j \in \mathcal{D} \hspace{1mm} \}$, and $A^L = \{(i,j) \hspace*{1mm} \vert \hspace*{1mm} i, j \in \mathcal{L} \hspace{1mm} \}$.
$A$ corresponds to allowed movements of drivers from node $i$ to node $j$. For each driver $k$, the allowed movements are the following:

\begin{itemize}
    \item From the starting depot $s_k$ to a loading dock $l \in \mathcal{L}$ or to the ending depot $e_k$.
    \item From a loading dock $l \in \mathcal{L}$ to a delivery node $d \in \mathcal{D}$.
    \item From a delivery node  $d \in \mathcal{D}$ to a loading dock $l \in \mathcal{L}$ or to the ending depot $e_k$.
\end{itemize}

For a customer $c$, arcs in $A^D$ link consecutive delivery nodes of the same order   $\lbrace (i,j)\in \mathcal{D}_o, o \in \mathcal{O}_c, i < j  \rbrace$, and pair of delivery nodes of two different orders $ \lbrace (i,d^{0}_{o_2}),  i \in \mathcal{D}_{o_1}, i \geq n^{min}_{o_1}, o_1, o_2 \in \mathcal{O}_c, o_1 \neq o_2 \rbrace $. Arcs in $A^L$ link all pairs of loading docks of the same batch plant.

We define $\delta^{+}(i) = \{(i, j,k) \in A \}$ and $\delta^{-}(i) = \{(j, i,k) \in A \}$ as the outcoming and incoming arc sets of node $i \in V$; $\delta^{+}_D(i) = \{(i, j)  \in A^D\}$ and $\delta^{-}_D(i) = \{(j, i) \in A^D \}$ are the outcoming and incoming arc sets of delivery node $i \in \mathcal{D}$.  Similarly, $\delta^{+}_L(i) = \{(i, j)  \in A^L\}$ and $\delta^{-}_L(i) = \{(j, i) \in A^L \}$ are the outcoming and incoming arc sets of loading node $i \in \mathcal{L}$.

Let the binary variable $x^{k}_{ij}$ be $1$ if driver $k$ travels from node $i$ to $j$. Binary variable $y_o$ is $1$ when order $o$ is completely served; $v_i$ and $w_i$ are the start and end of the loading (unloading) operation at node $i \in \mathcal{L}\cup \mathcal{D}$. Binary variable $u_{ij}$ is $1$ if node $j$ is served just after $i$, the service being either an unloading or a loading operation. % Binary variable $\sigma_{ib}$ is equal to 1 if the orders of customer $i$ are loaded by plant $b$. 
Variable $q^k_j$ is the quantity to be loaded towards $j$ with vehicle $k$. Let $w^1_k$ be a continuous variable indicating the difference between the driver's work time and the minimum number of hours to be worked in a day, and $w^2_k$ indicating the difference between the driver's work time and the normal work time. Let $g_i$ be the time between due date and first service start for customer $i$.

The objective function minimizes total travel cost ($TC$), penalties associated with unfulfilled orders ($PUO$), first delivery delays ($FDD$), driver underutilization costs ($DUC$), and driver overtime costs ($DOC$). Together, these components drive the optimization process to find a solution that efficiently balances travel costs, customer satisfaction, on-time delivery, driver utilization, and scheduling constraints.

% The objective function minimizes the total travel cost, the penalty costs incurred when customer demands are not fully met, the lateness of each customer's first delivery, the cost of drivers working less than the minimum hours, and the total overtime cost of drivers working beyond their scheduled hours. The mathematical model of this variant of the CDP is as follows:


\begin{alignat}{3}
    \label{mod:obj}   \min & \smashoperator{ \sum_{ \substack{(i,j,k) \in A} }} {t_{ij}x^{k}_{ij}} + \beta_1\smashoperator{\sum_{ o \in \mathcal{O}}}{  \left(1-y_o\right)} \hspace{-0mm}  + \beta_2 \smashoperator{ \sum_{i \in \mathcal{C} } } { g_i  } +  \sum_{k \in K}\left({\beta_3 w^{1}_k  + \beta_4  w^{2}_k}\right)  &                         \\
    \label{mod:c1}         & \sum_{j \in \delta^{+}(i) }{x^k_{ij}} =1       & \forall i \in S, k \in K                                                                         \\
    \label{mod:c2}         & \sum_{j \in \delta^{-}(i)}{x^k_{ji}} = 1   & \forall i \in E, k \in K                                                                         \\
    \label{mod:c03}        & v_j \geq  w_i  - M\left(1-x^{k}_{ij}\right)                                                                                                                                                                                                                                            & \hspace{-20mm}  i \in S, j \in \delta^{+}(i),  k \in K                                           \\
    \label{mod:c3}         & v_j \geq  w_i + \alpha_{b} + t_{ij} - M\left(1-x^{k}_{ij}\right)                                                                                                                                                                                                                       & \hspace{-20mm} \forall b \in \mathcal{B}, i \in \mathcal{L}_b, j \in \delta^{+}(i),  k \in K     \\
    \label{mod:c4}         & v_j \geq  w_i + \rho + t_{ij} - M\left(1-x^{k}_{ij}\right)                                                                                                                                                                                                                           & \hspace{-20mm} \forall i \in \mathcal{D}  , j \in \delta^{+}(i), k \in K                         \\
    \label{mod:c5}         & w_{i} \geq v_{i}  + \frac{q^k_j}{\tau^l_b} -M\left(1- x^{k}_{ij}\right)                                                                                                                                                                                                                & \hspace{-20mm} \forall  b \in \mathcal{B},  i \in \mathcal{L}_{b},  j \in \delta^{+}(i), k \in K \\
    \label{mod:c6}         & w_{j} \geq v_{j}  + {  \frac{q^k_j}{\tau^u_c} -M\left(1- x^{k}_{ij}\right) }                                                                                                                                                                                                           & \hspace{-20mm}  \forall c \in  \mathcal{C}, j \in \mathcal{D}_{c}, i \in \delta^{-}(j),  k \in K \\
    \label{mod:c7}         & w_{j} \leq v_{i}  + \Delta + M\left(1- x^{k}_{ij}\right)                                                                                                                                                                                                                               & \hspace{-20mm}   j \in \mathcal{D},  i \in \delta^{-}(j),  k \in K                               \\
    \label{mod:c8}         & v_{d^0_{o}} \geq a_i                                                                                                                                                                                                                                                                   & \hspace{-20mm} \forall  i \in \mathcal{C}, \forall o \in \mathcal{O}_i                           \\
    \label{mod:c9}         & g_{i} \geq v_{d^0_{o_1}} - a_i - M\left(  \sum_{ j \in \delta^{-}_{D}(d^0_{o_1})  }{u_{jd^0_{o_1}}}\right)                                                                                                                                                                             & \hspace{-20mm}  \forall  i \in \mathcal{C}, \forall o_1 \in \mathcal{O}_i                        \\
    \label{mod:c101}       & v_{d^0_{o_1}} \geq w_j - M\left(1- u_{jd^0_{o_1}}\right)                                                                                                                                                                                                                               & \hspace{-40mm}    \forall o_1 \in \mathcal{O}_i,  j \in \delta_{D}^{-}(d^0_{o_1})                \\
    \label{mod:c10}        & v_{d^0_{o_1}}  \leq  w_j + \gamma^2 + M\left(1- u_{j,d^0_{o_1}}\right)                                                                                                                                                                                                                 & \hspace{-20mm}  \forall  o_1 \in \mathcal{O},  j \in \delta_{D}^{-}(d^0_{o_1})                   \\
    \label{mod:c11}        & \sum_{ \substack{o_1 \in \mathcal{O}_i }}{ \sum_{ j \in \delta^{-}_{D}(d^0_{o_1})}}{u_{j,d^0_{o_1} } } = |\mathcal{O}_i|-1                                                                                                                                                             & \hspace{-20mm} \forall  i \in \mathcal{C},|\mathcal{O}_i| > 1                                    \\
    \label{mod:c12}        & \sum_{ \substack{o_1 \in \mathcal{O}_i }}\sum_{ j \in \delta^{+}_{D}(d^0_{o_1})}{u_{d^0_{o_1},j } } = |\mathcal{O}_i|-1                                                                                                                                                                & \hspace{-40mm} \forall  i \in \mathcal{C}, |\mathcal{O}_i| > 1                                   \\
    \label{mod:c13}        & \hspace{3mm} \smashoperator{ \sum_{ j \in \delta^{+}_{D}(d^0_{o_1})}}{u_{d^0_{o_1},j } } \leq 1                                                                                                                                                                                        & \hspace{-20mm}  \forall o_1 \in \mathcal{O}                                                      \\
    \label{mod:c14}        & \hspace{2mm} \smashoperator{ \sum_{ j \in \delta^{-}_{D}(d^0_{o_1})}}{u_{j,d^0_{o_1} } } \leq 1                                                                                                                                                                                        & \hspace{-20mm} \forall o_1 \in \mathcal{O}                                                       \\
    \label{mod:c15}        & \hspace{2mm} \smashoperator{ \sum_{ j \in \delta^{+}_{D}(d^0_{o_1})}}{u_{d^0_{o_1},j } } +\smashoperator{ \sum_{ j \in \delta^{-}_{D}(d^0_{o_1})}}{u_{j,d^0_{o_1} } } \geq 1                                                                                                           & \hspace{-20mm} \forall o_1 \in \mathcal{O}                                                       \\
    \label{mod:c16}        & v_{j} \geq w_{j-1} - M\left(1- u_{j-1,j}\right)                                                                                                                                                                                                                                        & \hspace{-20mm}  \forall o \in \mathcal{O}, j \in \mathcal{D}_{o}, j \geq 1                       \\
    \label{mod:c17}        & v_{j}  \leq  w_{j-1} + \gamma^1 + M\left(1- u_{j-1,j}\right)                                                                                                                                                                                                                           & \hspace{-20mm} \forall i \in \mathcal{C}, \forall o \in O_i, j \in \mathcal{D}_{o}, j \geq 1     \\
    \label{mod:c18}        & u_{j-1,j} \geq u_{j,j+1}                                                                                                                                                                                                                                                               & \hspace{-35mm} \forall o_1 \in\mathcal{O},  j \in \mathcal{D}_{o_1}, 1 \leq j \leq n_{o_{1}}-1   \\
    \label{mod:c19}        & u_{j-1,j} \geq \sum_{l \in \mathcal{L}}{x_{lj}}                                                                                                                                                                                                                                        & \hspace{-20mm}  \forall o_1 \in \mathcal{O}, j \in \mathcal{D}_{o_1}, j \geq 1                   \\
    \label{mod:c20}        & v_{j} \geq w_{i} - M\left(1- u_{i,j}\right)                                                                                                                                                                                                                                            & \hspace{-20mm}  \forall i \in \mathcal{L}, j \in \delta^{+}_{L}(i)                               \\
    \label{mod:c21}        & \hspace{3mm} \smashoperator{ \sum_{ j \in \delta^{+}_{L}(i)}}{u_{i,j } } \leq 1                                                                                                                                                                                                        & \hspace{-20mm}  \forall i \in \mathcal{L}                                                        \\
    \label{mod:c22}        & \hspace{2mm} \smashoperator{ \sum_{ j \in \delta^{-}_{L}(i)}}{u_{j,i } } \leq 1                                                                                                                                                                                                        & \hspace{-20mm} \forall i \in \mathcal{L}                                                         \\
    \label{mod:c230}       & \hspace{2mm} \smashoperator{ \sum_{ j \in \delta^{-}_{L}(i)}}{u_{j,i } }  \geq \sum_{k \in K}\sum_{j \in  \delta^{-}(i) }{x^k_{ji}}                                                                                                                                                    & \hspace{-20mm} \forall i \in \mathcal{L}                                                         \\
    \label{mod:c231}       & \hspace{2mm} \smashoperator{ \sum_{ j \in \delta^{-}_{L}(i)}}{u_{j,i } } \geq \smashoperator{ \sum_{ j \in \delta^{-}_{L}(i+1)}}{u_{j,i+1 } }                                                                                                                                          & \hspace{-20mm} \forall i \in \mathcal{L}                                                         \\
    \label{mod:c23}        & \hspace{2mm} \smashoperator{ \sum_{ j \in \delta^{-}_{L}(i)}}{u_{j,i } } + \smashoperator{ \sum_{ j \in \delta^{+}_{L}(i)}}{u_{i,j } } \geq \sum_{k \in K}\sum_{j \in  \delta^{-}(i) }{x^k_{ji}}                                                                                       & \hspace{-20mm} \forall i \in \mathcal{L}                                                         \\
    \label{mod:c24}        & \sum_{k \in K}\sum_{j \in \mathcal{D}_o}{q^k_j} = q_o                                                                                                                                                                                                                                  & \hspace{-20mm}  \forall o \in \mathcal{O}                                                        \\
    \label{mod:c240}       & q^k_j \leq \sum_{i \in  \delta^{-}(j)}{Q^k x^k_{ij}}                                                                                                                                                                                                                                   & \hspace{-20mm}  \forall j \in \mathcal{D}, k \in K                                               \\
    \label{mod:c25}        & \sum_{k \in K}\sum_{j \in \delta^{+}(i)}{x^{k}_{ij} \leq 1}                                                                                                                                                                                                                            & i \in \mathcal{L} \cup \mathcal{D}                                                               \\
    \label{mod:c26}        & \sum_{k \in K}\sum_{j \in \delta^{+}(i)} {x^{k}_{ij} } =  \sum_{k \in K}\sum_{j \in \delta^{-}(i)}{x^{k}_{ji} }                                                                                                                                                                        & i \in \mathcal{L} \cup \mathcal{D}                                                               \\
    % \label{mod:c27}        & \sum_{k \in K}  \sum_{i \in \mathcal{D}_c} \sum_{j \in \delta^{-}(i) }  {x^k_{ji}} \leq M\sigma_{c, b}     & \forall c \in \mathcal{C}, b \in \mathcal{B}                                                     \\
    % \label{mod:c28}        & \sum_{b \in \mathcal{B}} \sigma_{c, b} \leq 1    & \hspace{-20mm}\forall c \in \mathcal{C}, b \in \mathcal{B}                                       \\
    \label{mod:c29}        & w^1_k \geq  M_T + H_k - v_{e_k}                                                                                                                                                                                                                                                        & \hspace{-20mm} \forall k \in K                                                                   \\
    \label{mod:c30}        & w^2_k \geq (v_{e_k} - H_k) - N_T                                                                                                                                                                                                                                                       & \hspace{-20mm} \forall k \in K                                                                   \\
    \label{mod:c31}        & w_{e_k} \leq H_k + O_T                                                                                                                                                                                                                                                                 & \hspace{-00mm}  k \in K \hspace{0mm}                                                             \\
    \label{mod:c32}        & 0 \leq q^k_j \leq Q^k                                                                                                                                                                                                                                                                  & \hspace{-20mm}  j \in \mathcal{D}, k \in K                                                       \\
    \label{mod:c33}        & x^k_{ij} \in \{0,1\}                                                                                                                                                                                                                                                                   & \hspace{-20mm}  (i,j) \in A , k \in K  \hspace{0mm}                                              \\
    \label{mod:c34}        & u_{ij} \in \{0,1\}                                                                                                                                                                                                                                                                     & \hspace{-20mm}  (i,j) \in A^D , k \in K  \hspace{0mm}                                            \\
    % \label{mod:c35}        & \sigma_{ib} \in \{0,1\}    & \hspace{-20mm}  i \in \mathcal{C}, b \in \mathcal{B}                                             \\
    \label{mod:c36}        & y_o \in \{0,1\}                                                                                                                                                                                                                                                                        & \hspace{-20mm}  o \in \mathcal{O}                                                                \\
    \label{mod:c37}        & v_i \geq 0,  w_i \geq 0                                                                                                                                                                                                                                                                & \hspace{-20mm}  i \in V                                                                          \\
    \label{mod:c38}        & w^1_{k} \geq 0,  w^2_k \geq 0                                                                                                                                                                                                                                                          & \hspace{-20mm}  i \in V                                                                          \\
    \label{mod:cend}       & g_i \geq 0                                                                                                                                                                                                                                                                             & \hspace{-20mm}  i \in \mathcal{C}.
\end{alignat}

$\beta_1$ to $\beta_4$ are the penalty coefficients of each component of the objective function (\ref{mod:obj}). Constraints (\ref{mod:c1}) and (\ref{mod:c2}) state that driver $k$ leaves his start node exactly once a day and returns to his end node. A driver cannot serve a node before the start of his shift with constraints (\ref{mod:c03}). Constraints (\ref{mod:c3}) and (\ref{mod:c4}) set a driver to take some time after loading or unloading to adjust the concrete or clean the truck before moving on to the next node. The duration of the loading operation depends on the plant's loading rate and the amount $q^k_j$ of RMC loaded (\ref{mod:c5}). Similarly, the unloading service depends on the site's rate and $q^k_j$ (\ref{mod:c6}). Unloading operations must end at most $\Delta$ minutes after loading begins (\ref{mod:c7}).

Constraints (\ref{mod:c8}) - - (\ref{mod:c10}) ensure that the first service of any customer $i$ must start at the due time $a_i$. This first service may be performed at the first delivery node of any order $\in O_i$, and one order must be completed before another is started. It also enforces the precedence constraints between the last delivery of an order and the first delivery of the following order.
Constraints (\ref{mod:c11}) - - (\ref{mod:c15}) find the delivery sequence of all orders $\in \mathcal{O}_i$. With constraints (\ref{mod:c16}) - - (\ref{mod:c19}), two trucks cannot unload at the same time for consecutive deliveries of the same order. Additionally, these constraints impose a maximum time delay between the two trucks. Similarly, constraints (\ref{mod:c20}) - - (\ref{mod:c23}) ensure that two trucks cannot be loaded at the same time at a plant. Constraints (\ref{mod:c24}) require that the cumulative load of all concrete mixers serving an order must equal the required quantities, and (\ref{mod:c240}) bound a driver load.  Constraints (\ref{mod:c25}) require that a driver can only visit a loading/delivery node once. Constraints (\ref{mod:c26}) are degree constraints. Constraints (\ref{mod:c29}) - - (\ref{mod:c30}) calculate the difference between a driver's hours of service and the minimum and normal hours of service. Finally, constraints (\ref{mod:c31}) - - (\ref{mod:cend}) define the nature and bounds of the variables.

% \paragraph*{}
Let us consider the solution of a small instance of our problem shown in Figures~\ref{fig_Example} and \ref{fig:ganttExample}. Two batch plants $B_1$ and $B_2$ with three drivers serve two construction sites. Customer $C_1$ requests one order of $q^1_1=12$ m$^3$. Customer $C_2$ requests three orders of $q^1_2=3$, $q^2_2=11$, and $q^3_2=1$ m$^3$ of three different types of concrete. $B_1$ has two drivers ($D_1$, $D_2$) using concrete mixers of capacity 8 m$^3$, and $B_2$ has $D_3$ with a capacity 12 m$^3$. Figure~\ref{fig_Example} shows the flow of concrete mixers flow in the network. We schedule $D_1$ and $D_2$ to deliver 8 and 4 m$^3$ to $C_1$, respectively. We select $o^2_2$ as the first order of $C_2$. $D_3$ travels to $B_1$ to load $q^2_2$, then visits $C_2$ before returning to his home plant. Meanwhile, after their first trip,  $D_1$ and $D_2$ deliver the remaining orders of $C_2$.

Figure~\ref{fig:ganttExample} shows the sequence of loading and unloading operations. The first deliveries of $C_1$ and $C_2$ are timely and there is no gap between the two deliveries received by $C_1$. There is a delay between the end of the first delivery and the start of the second delivery of $C_2$, however, it is less than the maximal time delay of 20 minutes defined for this example.


\begin{figure}[htbp]
    % \caption{Solution of an instance with two plants, two construction sites, four orders, and three drivers.}
    \vspace*{-10mm}

    \centering
    \begin{adjustbox}{max width=0.85\textwidth}

        \begin{tikzpicture}
            \SetUpEdge[lw = 1.2pt,
                labelcolor = white,
                % labelstyle = {draw}
            ]
            \tikzstyle{LabelStyle}=[fill=white]

            \SetGraphUnit{5}
            \GraphInit[vstyle=Normal]
            \tikzset{VertexStyle/.style = {shape = circle,text = black,minimum size = 24 pt,draw = black}}
            \Vertex[L={$B_1$}]{D1}
            \tikzset{VertexStyle/.style = {shape = circle,text = black,minimum size = 10 pt,draw = blue}}
            \tikzset{VertexStyle/.style = {shape = rectangle,text = black,minimum size = 10 pt,draw = blue}}
            \Vertex[x=2,y=5,L={11 m$^3$}]{C21}
            \EA[unit=2.0,L={3 m$^3$}](C21){C22}
            \EA[unit=2.0,L={1 m$^3$}](C22){C23}
            \tikzset{VertexStyle/.style = {shape = rectangle,text = black,minimum size = 10 pt,draw = blue}}
            \SOEA[L={$12m^3$}](D1){C1}
            \tikzset{VertexStyle/.style = {shape = circle,text = black,minimum size = 24 pt,draw = black}}
            \SOEA[L={$B_2$}](C23){D2}
            % %  \SetVertexArt
            \tikzset{VertexStyle/.style = {shape = circle,text = black,minimum size = 10 pt}}
            \SO[unit=0.8,L={$\tau^u_1=$30 $m^3/h$, 07:00 AM}](C1){tau1}
            \SO[unit=0.5,L={\textbf{$C_1$} }](tau1){o1}

            \NO[unit=0.9,L={\textbf{$C_2$}}](C22){C2}
            \SOEA[unit=0.4,L={\textcolor{white}{  } $\tau^u_2=30$ $m^3/h$, 07:25 AM}](C2){tau2}

            \tikzset{VertexStyle/.style = {shape = rectangle,text = black,minimum size = 10 pt}}
            \SOWE[unit=1.,L={$\tau^l_1=$ 70 $m^3/h$}](D1){cap1}
            \SO[unit=0.5,L={\textbf{\textcolor{brown}{D1: 8 m$^3$}}}](cap1){driver11}
            \SO[unit=0.5,L={\textbf{\textcolor{orange}{D2: 8 m$^3$}}}](driver11){driver12}
            \SO[unit=1,L={$\tau^l_2= 87$ $m^3/h$}](D2){cap2}
            \SO[unit=0.5,L={\textbf{\textcolor{blue}{D3: 12 m$^3$}}}](cap2){driver2}
            %%%%%%% Edge
            \tikzset{EdgeStyle/.style={->}}
            \Edge[](C21)(C22)
            \Edge[](C22)(C23)
            \tikzset{EdgeStyle/.style={<->,bend left=0}}
            \Edge[label=$22$](D1)(C1)
            \tikzset{EdgeStyle/.style={<->}}
            \Edge[label=$19$](D2)(C23)
            \Edge[label=$34$](D2)(C1)
            \tikzset{EdgeStyle/.style={->}}
            \tikzset{EdgeStyle/.append style = {bend left = 8}}
            \Edge[label=$17$](D1)(D2)
            \Edge[label=$18$](D2)(D1)
            \tikzset{EdgeStyle/.append style = {bend left = 65}}
            \Edge[label=$6$](D1)(C21)
            \tikzset{EdgeStyle/.append style = {bend right = 50}}
            \Edge[label=$5$](C21)(D1)
            \tikzset{EdgeStyle/.style = {->,bend left = 20,draw=brown}}
            \Edge[label=$D1$](D1)(C1)
            \Edge[label=$D1$](C1)(D1)
            \tikzset{EdgeStyle/.style = {->,bend left = 37,draw=orange}}
            \Edge[label=$D2$](C1)(D1)
            \Edge[label=$D2$](D1)(C1)

            \tikzset{EdgeStyle/.style = {->,bend left= 20,draw=brown}}
            \Edge[label=$D1$](D1)(C22)
            \tikzset{EdgeStyle/.style = {->,bend left= 0,draw=brown}}
            \Edge[label=$D1$](C22)(D1)

            \tikzset{EdgeStyle/.style = {->,bend left = 0,draw=orange}}
            \Edge[label=$D2$](C23)(D1)
            \tikzset{EdgeStyle/.style = {->,bend left = -15,draw=orange}}
            \Edge[label=$D2$](D1)(C23)


            \tikzset{EdgeStyle/.style = {->,,draw=blue}}
            \Edge[label=$D3$](D2)(D1)
            \tikzset{EdgeStyle/.style = {->,bend left = 15,draw=blue}}
            \Edge[label=$D3$](D1)(C21)
            \tikzset{EdgeStyle/.style = {->,bend left = 80,draw=blue}}
            \Edge[label=$D3$](C21)(D2)
        \end{tikzpicture}
    \end{adjustbox}
    \vspace*{-10mm}
    % }
    \caption{Solution of an instance with two plants, two construction sites, four orders, and three drivers.}
    \label{fig_Example}

\end{figure}

\begin{figure}[htbp]
    \centering

    \vspace*{-0mm}
    \begin{adjustbox}{max width=0.85\textwidth}
        \begin{tikzpicture}[-latex]
            \matrix (chart)
            [
            matrix of nodes, nodes in empty cells,
            column sep      = 0em,
            row sep         = 3ex,
            column 1/.style = {nodes={label}},    column 2/.style = {},       column 3/.style = {nodes={env}},      column 4/.style = {nodes={env}},         column 5/.style = {nodes={env}},         column 6/.style = {nodes={env}},           column 7/.style = {nodes={env}},           column 8/.style = {nodes={env}},           column 9/.style = {nodes={env}},           column 10/.style = {nodes={env}},         column 11/.style = {nodes={env}},           column 12/.style = {nodes={env}},    column 13/.style = {nodes={env}}
            ]
            {
            $C_2-D_2$ (1 m$^3$) &
            &   &   &   &   &   &   &   &   &   &   &   &            |[LC23]| L &            &       &     |[UC23]| U \\
            $C_2-D_1$ (3 m$^3$) &           &      &        &        &           &            &            &
            &
            &
            &
            |[LC21]| L &
            &
            &
            &
            |[UC21]| U &
            \\
            $C_2-D_3$ (11 m$^3$) &
            &
            &
            &
            &
            &
            |[LC22]| L &
            &
            &
            |[UC22]| &
            |[UC22]|U  &
            |[UC221]|  &
            &
            &
            &
            &
            \\
            $C_1-D_2$ (4 m$^3$) &
            &
            &
            &
            |[LC12]| L &
            &
            &
            &
            |[UC12]| U &
            &
            &
            &
            &
            &
            &
            &
            \\
            $C_1-D_1$ (8 m$^3$) &
            &
            |[LC11]| L &
            &
            &
            &
            |[UC11]|U &
            |[UC11]| &
            &
            &
            &
            &
            &
            &
            &
            &
            \\
            \vspace*{-10em}
            Start time &&
            06:21 &
            &
            06:40 &
            &
            07:00 &
            &
            07:16 &  07:25 &
            &
            07:43 &
            &
            07:51 &
            &
            08:02 & 08:08 \\
            };
            % \node[fit={(chart-3-10) (chart-3-12)},style=UC22]{U};
            \draw (chart-5-3) edge (chart-5-7);
            % \draw (chart-5-8.3) edge (chart-2-12);
            \draw  (chart-4-5) edge (chart-4-9);
            % \draw  (chart-4-9) edge (chart-1-14);
            \draw  (chart-3-7) edge (chart-3-10);
            \draw  (chart-2-12) edge (chart-2-16);
            \draw  (chart-1-14) edge (chart-1-17);

        \end{tikzpicture}
    \end{adjustbox}
    \caption{Schedule of the instance of Figure~\ref{fig_Example}.}
    \label{fig:ganttExample}
\end{figure}


\section{Constructive heuristics and GRASP}
\label{grasp_method}

In this section, we present the heuristic approach we implement to solve this variant of the Concrete Delivery Problem. Our method consists of constructing feasible solutions to the CDP with randomized greedy heuristics and iteratively invoking these heuristics in the GRASP metaheuristic. From now on, we represent the scheduling of a delivery node $d$ as the pair  ($L^k_{d}$,$U^k_{d}$) of loading  and unloading  tasks. $L^k_{d} = \left(b,q_d,v_b,w_b\right)$ indicates that driver $k$ starts loading $q_d$ $m^3$ of RMC at plant $b$ between $\left[v_b,w_b\right]$. $U^k_{d} = \left(k,v_d, w_d\right)$ indicates that driver $k$ serves $d$ between $v_d$ and $w_d$. We then call a solution $ S =\left\lbrace \cup _{1 \leq j \leq |\mathcal{D}|} (L^k_{j}, U^k_{j}), k \in K \right\rbrace$ the set of all loading and unloading tasks performed on a given day.

\subsection{GRASP algorithm }

The GRASP algorithm, proposed by \cite{feo1989probabilistic}, is a two-phase iterative suite consisting of constructive and local search algorithms. In the construction phase, a feasible solution $S$ is generated using a greedy randomized algorithm. Then, a local search algorithm explores the neighborhood of $S$ to identify a local optimum. Algorithm~\ref{alg_grasp} outlines the pseudocode of the GRASP algorithm. To avoid redundant computations, a hash table $H$ is used to ensure that the local search is not applied multiple times to the same solution.  The procedure stops and returns the best overall solution when certain stopping conditions, such as reaching a time limit or a maximum number of iterations, are met. In our implementation, we also add a path relinking procedure that uses information about previous solutions to improve the search process.

    {\setstretch{1.0}
        {\small
        \begin{algorithm}[hpt]
            \caption{Pseudo-code of the GRASP algorithm }
            \label{alg_grasp}
            \DontPrintSemicolon
            \LinesNumbered
            \setcounter{AlgoLine}{0}
            % \KwIn{ \textit{H}: List of constructive greedy randomized heuristics }
            \KwIn{ $\phi$: number of iterations before path relinking }
            $S^* \leftarrow \emptyset$    \hspace{2mm} $T \leftarrow \emptyset$       $Cost(S^*) \leftarrow \infty$

            Initialize an empty hash table $H$

            $counter \leftarrow  0$

            \While{Conditions not met}{

                $S \leftarrow GreedyRandomizedHeuristic()$

                \uIf{ $S \notin H$}{
                    $S \leftarrow LocalSearch(S)$

                    Add $S$ to $H$
                }

                $T \leftarrow T \cup \{S\}$


                \uIf{$Cost(S)< Cost(S^*)$}{
                    $S^* \leftarrow S$
                }

                \uIf{$counter \text{ } mod \text{ } \phi == 0$}{
                    $S^* \leftarrow PathRelinking(T)$

                    $T \leftarrow \emptyset$
                }

                $counter \leftarrow counter + 1$

            }

            \KwRet{$S^{*}$}
        \end{algorithm}}
    }

For the construction phase, we have developed two greedy randomized heuristics. The first heuristic, called customer-based insertion, schedules customers one at a time. On the other hand, the second heuristic, called delivery-based insertion, does not necessarily complete the scheduling of one customer before starting to plan another customer's schedule.
% The greedy aspect of GRASP is the creation of the set $RCL$, the probabilistic aspect is the random selection in $RCL$, and the adaptive aspect is the updating of $CL$ and the re-evaluation of the incremental costs.

\subsection{Customer-based insertion heuristic}

The customer-based insertion heuristic builds a solution from scratch by scheduling all of a customer's orders one at a time. As shown in Algorithm~\ref{alg:greedyCustIns}, for each customer, we randomly select the first order to schedule. To schedule an order, we iterate over each of its delivery nodes, find a feasible pair of task, and add it to the current solution. For a delivery node $d$, we check if the list of operations $M[d]$ is empty. If it is, for each available driver $k$ we simulate the loading and unloading operations $(L^k_d,U^k_d)$ with the procedure $SimulateVisit$, and if $k$ can serve $d$, we add $k$ to a candidate list $CL$ and $(L^k_d,U^k_d)$ to $M[d]$.

The $SimulateVisit$ procedure takes a partial solution, a delivery node $d$, a driver $k$ and a numeric value $\lambda$ as parameters. Its goal is to find the earliest time when an unloading service can start at $d$ and the best position within the route of $k$. When planning to visit node $d$ of order $o$ and customer $i$ with driver $k$, we first compute his expected delivery time $v_d$ as follows:

$ v_d = \left\{
    \begin{array}{rl}
        a_i + \lambda                                                   & \text{for the first visited node} \\
        w_j + rand(\lambda, \gamma^1), j \in \mathcal{D}_o,  u_{jd}=1   &                                   \\
        w_j + rand(\lambda, \gamma^2), j \notin \mathcal{D}_o, u_{jd}=1 &
    \end{array}
    \right.$

Then we determine the start loading time $v_l$ of the corresponding dock node $l$ by subtracting the travel time, adjustment time, and loading duration from $v_d$. Starting from $v_l$ we check when $k$ will be available at an idle loading bay and adjust $w_l$ accordingly. Changing $w_l$ can cause the cold-joint constraints to be violated, especially for a customer's subsequent deliveries, and thus make the schedule infeasible. Once we have $v_l$, we can check for the best position to insert the visit of $d$ into the route of $k$.

We extract from $CL$ the restricted candidate list ($RCL$) of drivers for whom the cost of visiting $d$ falls within a specified range based on the parameter $\theta$. If $RCL$ is empty and a visit to $d$ cannot be scheduled due to cold-joint constraints, we use the $DelayPreviousDelivery$ procedure to determine if there is a previous delivery of the same order that we can delay the start of service to make a visit to $d$ feasible. This procedure returns the index of the node and $\lambda$, which is the value of the delay. $\lambda$ is also the same parameter given to $SimulateVisit$. If there is such a previous node, we backtrack to it and restart the scheduling.

If $RCL$ is not empty, we select a random driver from it, insert its corresponding load and unload tasks into $S$, and update the remaining quantities for the order and customer demands. The algorithm returns at the end the constructed solution $S$.


    {\setstretch{1}
        %  {\small
        \begin{algorithm}[]
            \caption{Customer-Based insertion algorithm }
            \label{alg:greedyCustIns}
            \DontPrintSemicolon
            \LinesNumbered
            \setcounter{AlgoLine}{0}
            \KwIn{  $S$: empty solution $S$, $K$: vehicles set \hspace{15mm} \\$\Pi$: custom sorted customers list }

            $M \leftarrow \emptyset $ \tcp{List of pair of loading and unloading tasks for all delivery nodes}
            $CL \leftarrow \emptyset$ \tcp{Candidate driver list all delivery nodes}

            \ForEach(customer $i \in \Pi$){}{

            Shuffle $ \mathcal{O}_i$

            \ForEach{order $o_1 \in \mathcal{O}_i$}{

            $\lambda \leftarrow 0$

            \For{ $j=0$ \KwTo $n^{max}_{o_1}-1$    }{

            Delivery $d =\mathcal{D}^j_{o_1}$

            \uIf{$M[d] == \emptyset $}{

            \ForEach{ $k \in K$  }{

            $(L^k_{d}$, $U^k_{d})$ $\leftarrow $ SimulateVisit($S$,$d$,$k$,$\lambda$)

            $Cost(d,k)$ $\leftarrow $ Cost of ($L^k_{d}$, $U^k_{d}$)

            Add $(L^k_{d}, U^k_{d}$) to $M[d]$

            $CL[d] \leftarrow \{k\}$
            }
            }

            $C_{min} \leftarrow min\left\lbrace C(x), \text{ } x \in M[d] \right\rbrace $, $C_{max} \leftarrow max\left\lbrace C(x), \text{ } x \in M[d] \right\rbrace $

            $RCL \leftarrow \left\lbrace k \in CL[d], \text{ } C(d,k) \leq C_{min} + \theta (C_{max}-C_{min}) \right\rbrace $


            \uIf{$RCL == \emptyset $}{

                $(ind,delay)$ = $DelayPreviousDelivery$($S$,$d$)

                \uIf{j is none}{

                    break \tcp{continue with next customer}
                }
                $j \leftarrow ind$, $\lambda \leftarrow delay$

                continue \tcp{backtrack to $ind$ position }

            }
            Select from $RCL$ a random driver $k$ to visit $d$ with load $q^k_d$

            $M[d]\leftarrow M[d] \backslash (L^k_{d}, U^k_{d})$, $CL[d]\leftarrow CL[d] \backslash \{k\} $

            $S \leftarrow S \cup (L^k_{d}$, $U^k_{d})  $

            $q_i \leftarrow q_i-q^k_{d}$;  $q_{o_1} \leftarrow q_{o_1}-q^k_{d}$

            $\lambda \leftarrow 0$

            \uIf {$q_{o_1} \neq 0$ }{
                continue

            }
            \uElseIf{ $q_i \neq 0$}{
                break

            }
            }
            }
            }

            \KwRet{$S$}
        \end{algorithm}
        %  }
    }

Consider the scenario where two customers require their services to start at the same time or within the same time window. In this case, we can either finish scheduling one customer before the other, or schedule both simultaneously.  If there are sufficient resources available, either option would be feasible. However, when resources are limited, the customer-based insertion heuristic may leave some customers unscheduled. To address this limitation, we introduce the delivery-based insertion heuristic.

\subsection{Delivery-based insertion heuristic}

The delivery-based insertion heuristic constructs a feasible solution from scratch by scheduling a delivery node one at a time. The pseudocode for this heuristic is outlined in Algorithm~\ref{alg:delbasedIns}. It starts with an empty solution $S$ and initially fills $CL$ with the first delivery of a randomly selected order for each customer. Within each iteration of the $while$ loop, we filter $CL$ to obtain a reduced candidate list $CL'$ of deliveries from a given neighborhood. With this filtering, we can force the algorithm to schedule nodes with certain criteria first, which could be nodes from customers with the same demand, due date, or geographic area. We can also decide whether to schedule customers with the highest (or lowest) demand or the earliest (latest) due date first.

For each delivery $d$ in $CL'$, the algorithm determines the best available driver $k$ and adds the corresponding loading and unloading task $(L^k_d, U^k_d)$ to a list of tasks. This is done using the $SimulateVisit$ procedure described earlier. Next, the algorithm constructs a $RCL$ from the list of tasks. If it is empty, the algorithm proceeds to the next iteration. Otherwise, it randomly selects a pair of tasks from the $RCL$, inserts them into $S$, and updates the remaining order and customer quantities. If an order $o$ is not fulfilled after visiting $d^j_{o}$, we add its next delivery node $d^{j+1}_{o}$ to $CL$.  Otherwise, if the customer has remaining orders, we select the first delivery node $d^{0}_{o'}$ of another randomly selected order $o'$ and add it to $CL$.

    % The greedy aspect of GRASP is the creation of the set $RCL$, the probabilistic aspect is the random selection in $RCL$, and the adaptive aspect is the updating of $CL$ and the re-evaluation of the incremental costs.

    {\setstretch{1}
        %  {\small
        \begin{algorithm}[H]
            \caption{Delivery-based insertion algorithm }
            \label{alg:delbasedIns}
            \DontPrintSemicolon
            \LinesNumbered
            \setcounter{AlgoLine}{0}
            \KwIn{  $S$: empty solution $S$}

            $CL \leftarrow \emptyset$

            \ForEach(customer i){}{

            Select a random order $o_1 \in \mathcal{O}_i$

            $CL \leftarrow CL \cup \{d^0_{o_1}\}$
            }

            \While{$CL \neq \emptyset$}{

            $CL' \leftarrow \text{Filter (CL)} $

            $Tasks \leftarrow \emptyset $ \tcp{List of loading and unloading tasks}

            \ForEach( $d \in CL'$){}{

                % $C(d) \leftarrow$ incremental cost of inserting $d$

                $Tasks \leftarrow (L^k_d,U^k_d)$ \tcp{$k$ is the best available driver to visit $d$}

            }
            $C_{min} \leftarrow \min\left\lbrace Cost(x), \text{ } x \in Tasks \right\rbrace $, $C_{max} \leftarrow \max\left\lbrace Cost(x), \text{ } x \in Tasks \right\rbrace $

            $RCL \leftarrow \left\lbrace x \in Tasks, \text{ } Cost(x) \leq C_{min} + \theta (C_{max}-C_{min}) \right\rbrace $


            \uIf{$RCL \leftarrow \emptyset$}{
                continue
            }

            Select random operations $(L^k_{d^{j}_o},U^k_{d^{j}_o})$ of customer $i$ (order $o$) from $RCL$

            $ S \leftarrow S \cup (L^k_{{d^{j}_o}}, U^k_{{d^{j}_o}})$


            $q_i \leftarrow q_i-q^k_{d^{j}_o}$;  $q_{o} \leftarrow q_{o}-q^k_{d^{j}_o}$

            \uIf {$q_{o} \neq 0$ }{

                $CL \leftarrow CL \cup \{d^{j+1}_{o}\}$

            }
            \uElseIf{ $q_i \neq 0$}{

                Select another order $o' \in \mathcal{O}_i$

                $CL \leftarrow CL \cup \{d^{0}_{o'}\} $

            }

            Update $CL$
            }
            \KwRet{$S$}
        \end{algorithm}
        %  }
    }

\subsection{Local Search}

After the construction phase, the local search phase iteratively invokes five operators using a first-improvement strategy. The first operator (\textit{Swap Load}) exchanges loads between two deliveries of the same order. The \textit{Swap Driver} operator explores alternative driver assignments by swapping drivers assigned to two delivery nodes. The \textit{Relocate} operator removes a delivery node and places it in a different location. The \textit{Consolidate Load} operator assigns an order request initially split between two drivers to a single driver, if the driver's capacity allows. The \textit{Remove and Reschedule} operator selects an unscheduled customer, denoted $i$, within the current solution. It then identifies a set $C$ containing scheduled customers with the same time slot as $i$. All elements of $C$ are removed and rescheduled along with $i$. This local search process continues until no further improvements can be made or a timeout is reached.


\subsection{Path relinking}

After the construction and local search steps, it is possible that some customers remain unscheduled in one solution while being accommodated in another. The goal of the path relinking procedure is to use each customer's scheduling information from existing solutions and combine them effectively to construct a solution that schedules all customers. This algorithm iterates through each element of a pool of solutions and attempts to insert each customer's schedule into a newly constructed solution.

\section{Computational experiments}
\label{comp_exp}

In this section, we present and discuss the results of computational experiments conducted using the GRASP heuristic described in section~\ref{grasp_method}. The implementation of the GRASP algorithm is coded in C++. We run our experiments on the benchmark data used in \cite{kinable2014concrete}, and on a dataset extracted from delivery operations records provided by our industry partner.

\subsection{Generation of instances}
\newcommand{\nbInstance}{36}
The dataset used in this section was obtained from our partner and contains records representing delivery operations from up to 8 production centers over a period of $\nbInstance$ days. We have created $\nbInstance$ instances, where each instance corresponds to a daily operation. An instance contains information such as each driver's capacity, associated batch plant, and shift start time. For each customer, we have the due time, the total demand, and the number of orders (type of concrete) received. For each order, we have its demand and associated production plant. Finally, we have the loading capacity for each plant. The name of an instance has the format $C\_k\_n\_o\_z$, where $k$ is the number of available drivers, $n$ is the number of customers, $o$ is the total number of daily orders, and $z$ is the number of plants. The dataset is divided into small, medium, and large sets according to the total number of daily orders. We have summarized the dataset in the Table~\ref{tab:instances}.

\begin{table}[htpb]
    \centering
    \caption{Instances summary}
    \label{tab:instances}
    \resizebox*{0.8\textwidth}{!}{
    \begin{tabular}{lcccccc}
        \toprule
        {} &  \# &         Demand  &   \#Order & \#Client &  \#Driver & \#Depot \\
          &       &         (m$^3$)        &         &         &          &        \\
        \midrule
        Small  &     8 &    226.5-937.5 &     7-14 &    4-11 &    13-35 &    1-3 \\
        Medium &    14 &  1,160.5-2,971.0 &    43-98 &   40-89 &   76-137 &    6-8 \\
        Large  &    14 &  3,078.5-3,953.5 &  107-136 &  92-127 &  129-150 &    8 \\
        \bottomrule
        \end{tabular}  
    }
\end{table}


\subsubsection{Results for the instances of \cite{kinable2014concrete}}

\cite{kinable2014concrete} provided a benchmark dataset for their variant of the $CDP$. Although their primary objective is to maximize the total load delivered each day, without considering loading operations at a plant and ensuring deliveries within specified time windows, we still use this dataset to analyze and compare the performance of our algorithm under different conditions. Table \ref*{tab:cdp_instances} shows the performance of the GRASP heuristic along with the other methods (CP, MIP, SD-heuristic, and Hybrid) used in \cite{kinable2014concrete}.  For each method, the table shows the average execution time in milliseconds and the corresponding gap between the obtained solution and the upper bound provided by \cite{kinable2014concrete}.

\begin{table}[htbp]
    \centering
    \caption{Performance of the GRASP heuristic on the CDP benchmark instances}
    \label{tab:cdp_instances}
    \resizebox{1\textwidth}{!}{
    \begin{tabular}{@{}cccccccccccc@{}}
    \toprule
     &  & \multicolumn{2}{c}{CP} & \multicolumn{2}{c}{MIP} & \multicolumn{2}{c}{SD-heuristic} & \multicolumn{2}{c}{Hybrid} & \multicolumn{2}{c}{GRASP} \\ \cmidrule(l){3-10} \cmidrule(l){11-12} 
     &  & Gap (\%) & Time (ms) & Gap (\%) & Time (ms) & Gap (\%) & Time (ms) & Gap (\%) & Time (ms) & Gap (\%) & Time (ms) \\ \cmidrule(l){3-10} \cmidrule(l){11-12} 
    \multirow{2}{*}{Set A} & Avg & 4.2 & 197,012 & 7.3 & 13,405,798 & 9.1 & 23 & 7.0 & 100,765 & 5.7 & 13,186 \\ \cmidrule(l){2-10} \cmidrule(l){11-12} 
     & Opt & \multicolumn{2}{c}{40/64} & \multicolumn{2}{c}{37/64} & \multicolumn{2}{c}{30/64} & \multicolumn{2}{c}{35/64} & \multicolumn{2}{c}{35/64} \\ \cmidrule(l){3-10} \cmidrule(l){11-12} 
     \multirow{2}{*}{Set B} & Avg & 12.1 & 357,313 & - & - & 16.3 & 1,331 & - & - & 13.8 & 574,983\\ \cmidrule(l){2-10} \cmidrule(l){11-12} 
     & Opt & \multicolumn{2}{c}{55/128} & \multicolumn{2}{c}{-} & \multicolumn{2}{c}{40/128} & \multicolumn{2}{c}{-} & \multicolumn{2}{c}{44/128} \\ \bottomrule
    \end{tabular}
    }
\end{table}

Overall, the GRASP algorithm shows promise in providing near-optimal solutions in a relatively short time for this benchmark of the CDP, making it a suitable candidate for further analysis and real-world application. It outperformed all methods except CP, achieving an average distance of 5.7\% (13.8\%) with a runtime of 13,186 (574,983) milliseconds for Set A (Set B). The SD-heuristic appears to be much faster, but GRASP provides a better balance between solution quality and computation time. It should also be noted that the exact MIP, CP, and Hybrid are initialized with the results of the SD-heuristic.


\subsubsection{Results for the generated instances}

The computational results of our instances solved with the GRASP heuristic are summarized in the tables below. The stopping criterion is set to 20,000 iterations. The parameters used in our experiments are listed in Table~\ref*{tab:problem_parameters}.


\begin{table}[htpb]
    \centering
    \caption{Parameters of the real-world instances}
    \label{tab:problem_parameters}
%    \resizebox*{\textwidth}{!}{
    \begin{tabularx}{\textwidth}{Xr}
        \toprule
        \multicolumn{1}{c}{Parameter} & \multicolumn{1}{c}{Value} \\ \midrule
        Unloading duration ($\tau_c^u$) & 2 min$/m^3$ \\
        Cleaning duration ($\rho$) & 10 min \\
        Adjustment duration ($\alpha$) & 10 min \\
        Max travel time ($\Delta$) & 120 min \\
        Min working time ($M_T$) & 180 min \\
        Max working time ($N_T$) & 480 min \\
        Max overtime duration ($O_T$) & 120 min \\
        Max delay between two consecutive deliveries of the same order ($\gamma^1$) & 20 min \\
        Max delay between two consecutive deliveries of different orders ($\gamma^2)$ & 25 min \\
    %    $\beta_1$ & 10000  \\
    %    $\beta_2$ & 10000  \\
    %    $\beta_3$ & 1000  \\
    %    $\beta_4$ & 100  \\
        \bottomrule
    \end{tabularx}
%    }
\end{table}

Table \ref*{tab:runtime} shows the percentage of concrete delivered by varying the execution times of the algorithm. For small instances, all requests are delivered in less than five minutes, while for medium and large instances, over 99\% of requests are delivered.  For these instances, it takes more than ten minutes to ensure complete delivery of all orders.

\begin{table}[htbp]
    \centering
    \caption{RMC delivered within different runtimes}
    \label{tab:runtime}
    \resizebox*{0.5\textwidth}{!}{
        \begin{tabular}{llcccc}
            \toprule
            &  &      \multicolumn{4}{c}{Runtime (min)} \\
            \cmidrule{3-6}
            & &      5   & 10  &  30  & 60  \\
            %  & {} &         &         &        &        \\
            \midrule
            \multirow{1}{*}{Small} & \% Load &  100.00 &  100.00 &  100.0 &  100.0 \\
                %   & \# instances &    8 &    8 &    8 &    8 \\
            \cmidrule{2-6}
                  \multirow{1}{*}{Medium} & \% Load &   99.86 &   99.86 &  100.0 &  100.0 \\
                %   & \# instances &   13 &   13 &   14 &   14 \\
                  \cmidrule{2-6}
                  \multirow{1}{*}{Large} & \% Load &   99.79 &   99.93 &  100.0 &  100.0 \\
                %   & \# instances &   12 &   13 &   14 &   14 \\
            \bottomrule
            \end{tabular} 
    }
    
\end{table}

Table \ref*{tab:results_grasp_ls} shows the detailed results for each instance. The runtime is set to 3600 seconds. The table reports the requirements of each instance, the components of the objective function, the number of drivers used, and the execution time in seconds.
%  the travel cost ($TC$), the penalties associated with unfulfilled orders ($PUO$), the sum of the first delivery delays ($FDD$) for each customer, the sum of the driver underutilization costs ($DUC$) and driver overtime costs ($DOC$). 

All daily orders are served with our algorithm, using less drivers than the available fleet. For the small size instances, all first deliveries are timely, except for one instance. The sum of the driver underutilization costs ($DUC$) is high for medium and large instances. This indicates underutilization of the scheduled fleet. Some drivers are not scheduled at all or work very little. The sum of the driver overtime costs ($DOC$) is also high for these instances. This can be explained by the fact that the algorithm prefers to put certain drivers on overtime rather than use a driver who has to travel to another plant for a delivery, which would increase the travel cost ($TC$).

$FDD$ is the sum of the delays of the first deliveries. To get an idea of the actuel delay per customer, we report $mFDD$, which is the maximum delay for all first deliveries. This tells us that we have a maximum delay that varies between 0 and 12 minutes for small instances, 1 and 60 minutes for medium instances, and 50 to 60 minutes for large instances.

\begin{table}[htbp]
    \caption{Results with all instances}
    \label{tab:results_grasp_ls}
    \resizebox*{\textwidth}{!}{
        \begin{tabular}{llccccccccc}
        \toprule
        &   &  Demand &  $TC$ & $PUO$&  $FDD$ & $mFDD$ &  $DUC$ &  $DOC$ &  \#Drivers &  Time \\
        & \multicolumn{1}{c}{Instance} &  (m$^3$)  &(min)  &  & (min) &(min) &(min)    & (min) & & (s)\\
        \midrule
            \multirow{9}{*}{Small} & C\_13\_11\_12\_1 &          226.5 &     1243.55 &  0.0 &               0.00 &              0.00 &          66.01 &          0.00 &          13 &  3022.06 \\
                  & C\_13\_5\_8\_1 &          267.0 &      745.10 &  0.0 &               0.00 &              0.00 &           0.00 &          0.00 &          13 &  3027.39 \\
                  & C\_18\_6\_11\_2 &          333.5 &      753.26 &  0.0 &               0.00 &              0.00 &         653.78 &          0.00 &          17 &  3004.51 \\
                  & C\_15\_4\_7\_2 &          375.0 &     1013.11 &  0.0 &               0.00 &              0.00 &          56.79 &        244.61 &          15 &  3009.54 \\
                  & C\_19\_7\_8\_2 &          388.0 &     1714.74 &  0.0 &               0.00 &              0.00 &          97.56 &        283.83 &          19 &  3020.89 \\
                  & C\_29\_10\_14\_3 &          613.5 &     3724.29 &  0.0 &              12.41 &             12.41 &         246.04 &        454.51 &          28 &  3035.23 \\
                  & C\_31\_8\_11\_3 &          776.0 &     2297.20 &  0.0 &               0.00 &              0.00 &         627.37 &        539.96 &          30 &  3033.85 \\
                  & C\_35\_9\_10\_3 &          937.5 &     4077.20 &  0.0 &               0.00 &              0.00 &         720.00 &        866.98 &          31 &  3020.75 \\
                  \cmidrule{2-11}
                  \multirow{14}{*}{Medium} & C\_76\_40\_43\_6 &         1160.5 &     5715.53 &  0.0 &               1.00 &              1.00 &        3566.49 &        771.23 &          69 &  3021.92 \\
                  & C\_104\_42\_47\_8 &         1565.0 &     9114.62 &  0.0 &              23.00 &             16.24 &        4180.95 &        671.94 &          94 &  3047.99 \\
                  & C\_94\_63\_70\_7 &         1746.5 &    13888.90 &  0.0 &              19.86 &             12.40 &        1086.60 &       1477.76 &          94 &  3025.72 \\
                  & C\_116\_67\_78\_8 &         1839.5 &    13946.30 &  0.0 &              44.68 &              9.98 &        1578.90 &        639.28 &         116 &  3007.88 \\
                  & C\_116\_71\_82\_8 &         2060.0 &    12461.20 &  0.0 &              68.38 &             20.06 &        3119.66 &       1478.63 &         107 &  3028.24 \\
                  & C\_117\_57\_70\_6 &         2327.5 &    15066.80 &  0.0 &              83.79 &             16.44 &        1522.11 &       1892.64 &         117 &  3020.70 \\
                  & C\_137\_79\_83\_7 &         2425.0 &    18811.40 &  0.0 &             252.94 &             41.65 &        2193.63 &       1963.05 &         136 &  3025.83 \\
                  & C\_127\_66\_80\_8 &         2512.5 &    15177.80 &  0.0 &               2.00 &              2.00 &        1874.83 &        965.65 &         125 &  3007.70 \\
                  & C\_128\_68\_74\_7 &         2595.0 &    19133.50 &  0.0 &             251.77 &             54.40 &        1523.19 &       2924.28 &         128 &  3053.96 \\
                  & C\_136\_85\_97\_8 &         2673.0 &    16832.10 &  0.0 &             154.97 &             50.21 &        3507.40 &       1958.58 &         132 &  3028.15 \\
                  & C\_128\_78\_85\_8 &         2685.5 &    16927.30 &  0.0 &             202.26 &             50.12 &        1492.50 &       2794.21 &         128 &  3030.32 \\
                  & C\_131\_77\_85\_8 &         2893.5 &    17572.10 &  0.0 &             187.42 &             49.24 &        1803.22 &       1306.94 &         130 &  3040.74 \\
                  & C\_137\_89\_97\_7 &         2939.5 &    21934.10 &  0.0 &             697.18 &             59.10 &        1220.15 &       3038.33 &         137 &  3025.45 \\
                  & C\_133\_84\_98\_7 &         2971.0 &    22399.30 &  0.0 &             867.12 &             59.44 &         550.77 &       2887.51 &         133 &  3137.11 \\
                  \cmidrule{2-11}
                  \multirow{14}{*}{Large} & C\_132\_98\_109\_8 &         3078.5 &    23102.40 &  0.0 &             193.01 &             49.44 &         450.57 &       3931.83 &         132 &  3018.05 \\
                  & C\_129\_101\_119\_8 &         3229.0 &    18978.90 &  0.0 &             467.94 &             59.47 &        1084.78 &       2334.16 &         129 &  3179.81 \\
                  & C\_141\_114\_136\_8 &         3350.5 &    21760.00 &  0.0 &            1131.39 &             59.58 &        1284.13 &       2360.19 &         141 &  3056.56 \\
                  & C\_140\_114\_132\_8 &         3401.5 &    23259.00 &  0.0 &            1092.82 &             57.99 &         634.53 &       2705.26 &         140 &  3046.75 \\
                  & C\_143\_101\_123\_8 &         3437.5 &    24560.70 &  0.0 &             451.36 &             56.61 &        1663.43 &       4359.64 &         142 &  3039.02 \\
                  & C\_137\_112\_129\_8 &         3471.0 &    21526.10 &  0.0 &             252.62 &             58.09 &         624.87 &       3360.64 &         137 &  3018.76 \\
                  & C\_142\_114\_129\_8 &         3499.5 &    21991.50 &  0.0 &             898.10 &             55.22 &        1750.60 &       4943.03 &         142 &  3011.54 \\
                  & C\_149\_98\_122\_8 &         3513.0 &    20696.60 &  0.0 &             839.56 &             52.60 &        2465.87 &       2892.55 &         149 &  3072.58 \\
                  & C\_139\_98\_108\_8 &         3541.0 &    20550.10 &  0.0 &             566.69 &             57.49 &        1438.11 &       2910.97 &         139 &  3011.84 \\
                  & C\_144\_108\_122\_8 &         3670.5 &    23401.60 &  0.0 &             668.15 &             59.77 &        1438.60 &       3569.62 &         143 &  3056.51 \\
                  & C\_142\_92\_107\_8 &         3684.5 &    22700.20 &  0.0 &             147.42 &             48.31 &         899.82 &       3702.01 &         142 &  3019.52 \\
                  & C\_138\_114\_136\_8 &         3739.5 &    24670.70 &  0.0 &             750.04 &             55.88 &         518.63 &       5156.41 &         137 &  3021.26 \\
                  & C\_150\_127\_136\_8 &         3946.5 &    25822.20 &  0.0 &             742.75 &             57.10 &         899.92 &       5101.58 &         150 &  3060.79 \\
                  & C\_148\_112\_131\_8 &         3953.5 &    25455.30 &  0.0 &             868.81 &             49.15 &         500.68 &       3775.57 &         148 &  3005.96 \\
            \bottomrule
            \end{tabular}
    }
\end{table}

We tried to reduce the maximum delay of the first delivery but found that some orders couldn't be fulfilled because of driver shifts and overtime constraints. We decided to remove these constraints and rerun our computation. We found that for small instances, the maximum delay dropped to zero, and for medium and large instances, it was reduced by almost 50\%. This suggests that when we input a good work schedule, our algorithm works effectively to ensure that all orders are filled and that delays for first deliveries and travel costs are minimized. In Table~\ref*{tab:lift_shift_constraints}, we can see that the average travel time decreases for all instances except the large ones. That's because the goals of minimizing travel cost and not delaying the first delivery are sometimes in conflict: to ensure that the first delivery is not late, drivers assigned to one plant often have to travel to another. And since all plants are used in large cases, this can increase travel times. 

%  Therefore, we can use our algorithm for fleet sizing or as a submodule of a driver scheduling algorithm.

\begin{table}[htbp]
    \centering
    \caption{Comparaison with and without shift and overtime constraints}
    \label{tab:lift_shift_constraints}
    \resizebox*{0.8\textwidth}{!}{
        \begin{tabular}{lcccccccc}
            \toprule
        {} & \multicolumn{4}{c}{Default parameters} &\multicolumn{4}{c}{$M_T=0$, $N_T,O_T=\infty$, $H_k=0$} \\
        \cmidrule(l){2-5} \cmidrule(l){6-9}
        {} &   Load & $TC$ &   $FDD$ &  $mFDD$ &   Load &      $TC$ &   $FDD$ &   $mFDD$ \\
               &($m^3$)  & (min)   &(min)   &(min)  &($m^3$)   &  (min) &(min)  & (min)   \\
            \midrule
            Small  &   489.62 &   1946.06 &    1.55 &       1.55 &   489.62 &   1832.90 &    0.00 &       0.00 \\
            Medium &  2313.86 &  15641.50 &  204.03 &      31.59 &  2313.86 &  14607.66 &   74.76 &      16.56 \\
            Large  &  3536.86 &  22748.24 &  647.90 &      55.48 &  3536.86 &  22293.04 &  210.14 &      29.00 \\
            \bottomrule
            \end{tabular}
             
    }
    
\end{table}

The influence of the parameter $\gamma^1$ on the solution quality is demonstrated in Figure~\ref*{fig:gamma1_influence}. Tests were conducted by varying $\gamma^1$ values between 10 and 25 minutes, without any driver shifts or overtime constraints. In small instances, all customers are served regardless of the value of $\gamma^1$. For medium (large) instances, all customers are served with $\lambda^1$ starting at 15 (20) minutes. The delay of the initial delivery decreases as the value of $\gamma^1$ increases. The results indicate that if $\gamma^1$ is high, the plant has the flexibility to delay ongoing deliveries to make room for new ones or make customers wait until the drivers are available. By increasing the maximum delay between two successive deliveries from 10 to 20 minutes, the first delivery delay is reduced by over 50\% for the medium and large size instances. The average travel time remains constant for all instances, regardless of the value of $\gamma^1$.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{gamma1.pdf} 
    \caption{Influence of the maximum time delay between consecutive deliveries of the same order ($\gamma^1$)}
    \label{fig:gamma1_influence}
\end{figure}

We checked how well the local search part of the GRASP algorithm works by running tests using only constructive heuristics. The results are presented in Table~\ref*{tab:grasp_ls_nols}. For medium and large instances, the use of local search was necessary to service all customers within 60 minutes. And without local search, most objective metrics experienced a significant increase, except for travel costs.

\begin{table}[htbp]
    \centering
    \caption{Influence of the local search step on the  GRASP algorithm}
    \label{tab:grasp_ls_nols}
    \resizebox*{1\textwidth}{!}{
    \begin{tabular}{lccccccccccccc}
        \toprule
           & &\multicolumn{5}{c}{GRASP$\backslash$LS} & \multicolumn{5}{c}{GRASP}   \\
           \cmidrule(l){2-14}
        {size} &Load &&$TC$&   $FDD$ &  $DUC$ &  $DOC$ & Time&&  $TC$ &  $FDD$&  $DUC$ &  $DOC$&Time \\
        {} & (m$^3$)&\%Served&(min)&   (min) &  (min) &  (min) & (min)&\%Served&  (min) &  (min)&  (min) &  (min)& (min) \\
        \cmidrule(l){2-2} \cmidrule(l){3-8} \cmidrule(l){9-14}
        Small  & 3917.0& 100 &       1998.75 &   64.60 &           231.63 &          215.43 &21.24& 100&      1946.06 &    1.55 &    229.40 &          298.74 &50.34\\
        Medium & 32394.0& 99.6&     13144.05 &   2528.33 &  2496.47 & 1086.12 &49.41&100&  13564.08 &   75.77 &   2250.66 &         1347.59&50.6 \\
        Large  & 49516.0& 99.2& 21395.23 & 4885.11 &  1250.14 &  3543.16 & 50.20&100&     21784.95 &  471.62 & 1168.73 &  3640.04&50.74 \\
        \bottomrule
        \end{tabular}
    }  
\end{table}

\subsubsection{Comparisons with the real operations}


- resultats avec les instances (8 au total) où uniquement la flotte de Unibéton a éét utilisée.
enlver les contraintes de temps. reduire le gamma1


(utiliser les mêmes pour la comparaison avec les données réelles )
distance, demande servie, first, underwork, overtime.
- resultats avec les autres instances
- distance, demande servie, first delivery.
- rouler les instances sans shift des livreurs. comparer la distance parcourue, et demande livrée.
- rouler sans les livreurs externes. regarder la demande servie par jour. 

\section{Conclusion}
\label{concl}

Il serait intéressant de voir l'effet des paramètres lambda 1 et lambda 2 différents par clients et /ou ordre. Également le temps de service différent par client. 

l'algorithme serait intéressant à utiliser dans le cadre d'un 

%  Therefore, we can use our algorithm for fleet sizing or as a submodule of a driver scheduling algorithm.

\vspace{0.1in}


\vspace{1.5cm} \noindent \textbf{Acknowledgments}

Financial support for this work was provided by the Canadian Natural Sciences and Engineering Research Council (NSERC) under grants 2015-04893 and 2019-00094. This support is gratefully acknowledged.


\bibliographystyle{plainnat}
\bibliography{References}








\end{document}